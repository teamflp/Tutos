<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <title>Apprendre JavaScript</title>

    <style>
        /* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
        /*---------------------------------------------------------------------------------------------
    *  Copyright (c) Microsoft Corporation. All rights reserved.
    *  Licensed under the MIT License. See License.txt in the project root for license information.
    *--------------------------------------------------------------------------------------------*/

        body {
            font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
            font-size: var(--vscode-markdown-font-size, 14px);
            padding: 0 26px;
            line-height: var(--vscode-markdown-line-height, 22px);
            word-wrap: break-word;
        }

        #code-csp-warning {
            position: fixed;
            top: 0;
            right: 0;
            color: white;
            margin: 16px;
            text-align: center;
            font-size: 12px;
            font-family: sans-serif;
            background-color: #444444;
            cursor: pointer;
            padding: 6px;
            box-shadow: 1px 1px 1px rgba(0, 0, 0, .25);
        }

        #code-csp-warning:hover {
            text-decoration: none;
            background-color: #007acc;
            box-shadow: 2px 2px 2px rgba(0, 0, 0, .25);
        }

        body.scrollBeyondLastLine {
            margin-bottom: calc(100vh - 22px);
        }

        body.showEditorSelection .code-line {
            position: relative;
        }

        body.showEditorSelection .code-active-line:before,
        body.showEditorSelection .code-line:hover:before {
            content: "";
            display: block;
            position: absolute;
            top: 0;
            left: -12px;
            height: 100%;
        }

        body.showEditorSelection li.code-active-line:before,
        body.showEditorSelection li.code-line:hover:before {
            left: -30px;
        }

        .vscode-light.showEditorSelection .code-active-line:before {
            border-left: 3px solid rgba(0, 0, 0, 0.15);
        }

        .vscode-light.showEditorSelection .code-line:hover:before {
            border-left: 3px solid rgba(0, 0, 0, 0.40);
        }

        .vscode-light.showEditorSelection .code-line .code-line:hover:before {
            border-left: none;
        }

        .vscode-dark.showEditorSelection .code-active-line:before {
            border-left: 3px solid rgba(255, 255, 255, 0.4);
        }

        .vscode-dark.showEditorSelection .code-line:hover:before {
            border-left: 3px solid rgba(255, 255, 255, 0.60);
        }

        .vscode-dark.showEditorSelection .code-line .code-line:hover:before {
            border-left: none;
        }

        .vscode-high-contrast.showEditorSelection .code-active-line:before {
            border-left: 3px solid rgba(255, 160, 0, 0.7);
        }

        .vscode-high-contrast.showEditorSelection .code-line:hover:before {
            border-left: 3px solid rgba(255, 160, 0, 1);
        }

        .vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
            border-left: none;
        }

        img {
            max-width: 100%;
            max-height: 100%;
        }

        a {
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        a:focus,
        input:focus,
        select:focus,
        textarea:focus {
            outline: 1px solid -webkit-focus-ring-color;
            outline-offset: -1px;
        }

        hr {
            border: 0;
            height: 2px;
            border-bottom: 2px solid;
        }

        h1 {
            padding-bottom: 0.3em;
            line-height: 1.2;
            border-bottom-width: 1px;
            border-bottom-style: solid;
        }

        h1,
        h2,
        h3 {
            font-weight: normal;
        }

        table {
            border-collapse: collapse;
        }

        table>thead>tr>th {
            text-align: left;
            border-bottom: 1px solid;
        }

        table>thead>tr>th,
        table>thead>tr>td,
        table>tbody>tr>th,
        table>tbody>tr>td {
            padding: 5px 10px;
        }

        table>tbody>tr+tr>td {
            border-top: 1px solid;
        }

        blockquote {
            margin: 0 7px 0 5px;
            padding: 0 16px 0 10px;
            border-left-width: 5px;
            border-left-style: solid;
        }

        code {
            font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
            font-size: 1em;
            line-height: 1.357em;
        }

        body.wordWrap pre {
            white-space: pre-wrap;
        }

        pre:not(.hljs),
        pre.hljs code>div {
            padding: 16px;
            border-radius: 3px;
            overflow: auto;
        }

        pre code {
            color: var(--vscode-editor-foreground);
            tab-size: 4;
        }

        /** Theming */

        .vscode-light pre {
            background-color: rgba(220, 220, 220, 0.4);
        }

        .vscode-dark pre {
            background-color: rgba(10, 10, 10, 0.4);
        }

        .vscode-high-contrast pre {
            background-color: rgb(0, 0, 0);
        }

        .vscode-high-contrast h1 {
            border-color: rgb(0, 0, 0);
        }

        .vscode-light table>thead>tr>th {
            border-color: rgba(0, 0, 0, 0.69);
        }

        .vscode-dark table>thead>tr>th {
            border-color: rgba(255, 255, 255, 0.69);
        }

        .vscode-light h1,
        .vscode-light hr,
        .vscode-light table>tbody>tr+tr>td {
            border-color: rgba(0, 0, 0, 0.18);
        }

        .vscode-dark h1,
        .vscode-dark hr,
        .vscode-dark table>tbody>tr+tr>td {
            border-color: rgba(255, 255, 255, 0.18);
        }
    </style>

    <style>
        /* Tomorrow Theme */
        /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
        /* Original theme - https://github.com/chriskempson/tomorrow-theme */

        /* Tomorrow Comment */
        .hljs-comment,
        .hljs-quote {
            color: #8e908c;
        }

        /* Tomorrow Red */
        .hljs-variable,
        .hljs-template-variable,
        .hljs-tag,
        .hljs-name,
        .hljs-selector-id,
        .hljs-selector-class,
        .hljs-regexp,
        .hljs-deletion {
            color: #c82829;
        }

        /* Tomorrow Orange */
        .hljs-number,
        .hljs-built_in,
        .hljs-builtin-name,
        .hljs-literal,
        .hljs-type,
        .hljs-params,
        .hljs-meta,
        .hljs-link {
            color: #f5871f;
        }

        /* Tomorrow Yellow */
        .hljs-attribute {
            color: #eab700;
        }

        /* Tomorrow Green */
        .hljs-string,
        .hljs-symbol,
        .hljs-bullet,
        .hljs-addition {
            color: #718c00;
        }

        /* Tomorrow Blue */
        .hljs-title,
        .hljs-section {
            color: #4271ae;
        }

        /* Tomorrow Purple */
        .hljs-keyword,
        .hljs-selector-tag {
            color: #8959a8;
        }

        .hljs {
            display: block;
            overflow-x: auto;
            color: #4d4d4c;
            padding: 0.5em;
        }

        .hljs-emphasis {
            font-style: italic;
        }

        .hljs-strong {
            font-weight: bold;
        }
    </style>

    <style>
        /*
    * Markdown PDF CSS
    */

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
            padding: 0 12px;
        }

        pre {
            background-color: #f8f8f8;
            border: 1px solid #cccccc;
            border-radius: 3px;
            overflow-x: auto;
            white-space: pre-wrap;
            overflow-wrap: break-word;
        }

        pre:not(.hljs) {
            padding: 23px;
            line-height: 19px;
        }

        blockquote {
            background: rgba(127, 127, 127, 0.1);
            border-color: rgba(0, 122, 204, 0.5);
        }

        .emoji {
            height: 1.4em;
        }

        code {
            font-size: 14px;
            line-height: 19px;
        }

        /* for inline code */
        :not(pre):not(.hljs)>code {
            color: #C9AE75;
            /* Change the old color so it seems less like an error */
            font-size: inherit;
        }

        /* Page Break : use <div class="page"/> to insert page break
    -------------------------------------------------------- */
        .page {
            page-break-after: always;
        }
    </style>

    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>

<body>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
                ? 'dark'
                : 'default'
        });
    </script>
    <h1 id="apprendre-%C3%A0-coder-en-javascript">APPRENDRE À CODER EN JAVASCRIPT</h1>
    <p>Auteur : <a href="https://gnpinformatique.fr">Paterne Guélablé Gnonzion</a></p>
    <p>Formateur développeur web et mobile : <strong>PHP, Symfony, Rust ...</strong></p>
    <p>Linkedin : <a href="https://www.linkedin.com/in/gnpinformatique/">Paterne G. G.</a></p>
    <p>Github : <a href="https://github.com/teamflp">teamflp</a></p>
    <h2 id="proc%C3%A9dure-pour-utiliser-ce-cours">Procédure pour utiliser ce cours</h2>
    <p>Bienvenue à ce cours sur le CSS ! Pour tirer le meilleur parti de ce contenu et acquérir une compréhension solide
        de la matière, suivez les étapes recommandées ci-dessous.</p>
    <ol>
        <li><strong>Préparation</strong> :</li>
    </ol>
    <ul>
        <li>Assurez-vous d'avoir les prérequis : connaissance basique du HTML et CSS.</li>
        <li>Installez un bon éditeur de code (comme <a href="https://code.visualstudio.com/">Visual Studio Code</a>).
        </li>
        <li>Configurez un navigateur moderne pour les tests (Chrome, Firefox, Safari, etc.).</li>
    </ul>
    <ol start="2">
        <li><strong>Étude systématique</strong> :</li>
    </ol>
    <ul>
        <li>Commencez par l'<strong>introduction</strong> pour comprendre le contexte du CSS.</li>
        <li>Poursuivez avec les <strong>bases</strong> avant de passer aux concepts avancés.</li>
        <li>Ne sautez pas de sections. Chaque partie est conçue pour s'appuyer sur la précédente.</li>
    </ul>
    <ol start="3">
        <li><strong>Pratiquez régulièrement</strong> :</li>
    </ol>
    <ul>
        <li>Après chaque section, prenez le temps de coder et de tester ce que vous avez appris.</li>
        <li>Utilisez les exemples fournis et essayez de les modifier ou de les améliorer.</li>
    </ul>
    <ol start="4">
        <li><strong>Participez à des discussions</strong> :</li>
    </ol>
    <ul>
        <li>Rejoignez des forums ou des groupes dédiés au CSS pour poser des questions, partager vos connaissances ou
            aider d'autres apprenants.</li>
        <li>Partager vos réalisations ou vos défis vous permettra d'obtenir des retours constructifs.</li>
    </ul>
    <ol start="5">
        <li><strong>Consultez des ressources supplémentaires</strong> :</li>
    </ol>
    <ul>
        <li>Explorez les <strong>ressources et outils</strong> mentionnés à la fin du cours pour approfondir vos
            connaissances et améliorer vos compétences.</li>
    </ul>
    <ol start="6">
        <li><strong>Mettez en pratique</strong> :</li>
    </ol>
    <ul>
        <li>Essayez de créer un petit projet web à partir de zéro, en appliquant tout ce que vous avez appris.</li>
        <li>Cela renforcera votre compréhension et vous donnera une idée des domaines dans lesquels vous pourriez avoir
            besoin de plus d'entraînement.</li>
    </ul>
    <ol start="7">
        <li><strong>Revenez régulièrement</strong> :</li>
    </ol>
    <ul>
        <li>La technologie et les normes évoluent. Revenez périodiquement pour mettre à jour vos connaissances ou
            rafraîchir certains concepts.</li>
    </ul>
    <ol start="8">
        <li><strong>Évaluez vos progrès</strong> :</li>
    </ol>
    <ul>
        <li>Testez régulièrement vos connaissances. Cela peut être à travers des quiz en ligne, des défis de codage ou
            des revues de code avec des pairs.</li>
    </ul>
    <p>Bonne étude ! Rappelez-vous que l'apprentissage est un voyage, et chaque étape vous rapproche de la maîtrise du
        JavaScript.</p>
    <!-- TOC -->
    <ul>
        <li><a href="#apprendre-%C3%A0-coder-en-javascript">APPRENDRE À CODER EN JAVASCRIPT</a>
            <ul>
                <li><a href="#proc%C3%A9dure-pour-utiliser-ce-cours">Procédure pour utiliser ce cours</a></li>
                <li><a href="#introduction-au-javascript">Introduction au JavaScript</a>
                    <ul>
                        <li><a href="#historique-et-%C3%A9volution-de-javascript">Historique et évolution de
                                JavaScript</a></li>
                        <li><a href="#pourquoi-utiliser-javascript-">Pourquoi utiliser JavaScript ?</a></li>
                        <li><a href="#diff%C3%A9rence-entre-java-et-javascript">Différence entre Java et JavaScript</a>
                        </li>
                        <li><a href="#environnement-dex%C3%A9cution-javascript">Environnement d'exécution JavaScript</a>
                        </li>
                        <li><a href="#outils-de-d%C3%A9veloppement">Outils de développement</a></li>
                    </ul>
                </li>
                <li><a href="#bases-du-javascript">Bases du JavaScript</a>
                    <ul>
                        <li><a href="#syntaxe-de-base">Syntaxe de base</a></li>
                        <li><a href="#types-de-donn%C3%A9es">Types de données</a></li>
                        <li><a href="#variables-et-constantes">Variables et constantes</a></li>
                        <li><a href="#affichage--consolelog-alert-et-prompt-documentwrite">Affichage : console.log(),
                                alert() et prompt(), document.write()</a></li>
                        <li><a href="#op%C3%A9rateurs">Opérateurs</a>
                            <ul>
                                <li><a href="#op%C3%A9rateurs-arithm%C3%A9tiques">Opérateurs arithmétiques</a></li>
                                <li><a href="#op%C3%A9rateurs-dassignation-----------et-----">Opérateurs d'assignation :
                                        <code>+</code>, <code>==</code>, <code>===</code>, <code>!=</code>,
                                        <code>!==</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>,
                                        <code>=&gt;</code> et <code>?</code> <code>:</code>, <code>&amp;&amp;</code>,
                                        <code>||</code>, <code>!</code></a></li>
                                <li><a href="#op%C3%A9rateurs-de-comparaison">Opérateurs de comparaison</a></li>
                                <li><a href="#op%C3%A9rateurs-logiques">Opérateurs logiques</a></li>
                                <li><a href="#op%C3%A9rateurs-de-concat%C3%A9nation">Opérateurs de concaténation</a>
                                </li>
                                <li><a href="#op%C3%A9rateurs-de-type">Opérateurs de type</a></li>
                                <li><a href="#op%C3%A9rateurs-de-bits">Opérateurs de bits</a></li>
                                <li><a
                                        href="#op%C3%A9rateurs-de-pr%C3%A9post-incr%C3%A9mentationd%C3%A9cr%C3%A9mentation">Opérateurs
                                        de pré/post-incrémentation/décrémentation</a></li>
                                <li><a href="#op%C3%A9rateurs-ternaires">Opérateurs ternaires</a></li>
                                <li><a href="#op%C3%A9rateurs-de-d%C3%A9composition">Opérateurs de décomposition</a>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#structures-conditionnelles">Structures conditionnelles</a>
                            <ul>
                                <li><a href="#ifelse">if...else</a></li>
                                <li><a href="#ifelse-ifelse">if...else if...else</a></li>
                                <li><a href="#switchcase">switch...case</a></li>
                            </ul>
                        </li>
                        <li><a href="#boucles">Boucles</a>
                            <ul>
                                <li><a href="#la-boucle-for">La boucle for</a></li>
                                <li><a href="#la-boucle-forin">La boucle for...in</a></li>
                                <li><a href="#la-boucle-forof">La boucle for...of</a></li>
                                <li><a href="#la-boucle-while">La boucle while</a></li>
                                <li><a href="#la-boucle-dowhile">La boucle do...while</a></li>
                                <li><a href="#la-boucle-foreach">La boucle forEach</a></li>
                                <li><a href="#la-boucle-forawaitof">La boucle for...await...of</a></li>
                            </ul>
                        </li>
                        <li><a href="#fonctions-en-javascript">Fonctions en JavaScript</a>
                            <ul>
                                <li><a href="#d%C3%A9claration-de-fonction">Déclaration de fonction</a></li>
                                <li><a href="#fonctions-anonymes">Fonctions anonymes</a></li>
                                <li><a href="#fonctions-fl%C3%A9ch%C3%A9es-es6">Fonctions fléchées (ES6)</a></li>
                                <li><a
                                        href="#fonctions-auto-ex%C3%A9cut%C3%A9es-iife---immediately-invoked-function-expression">Fonctions
                                        auto-exécutées (IIFE - Immediately Invoked Function Expression)</a></li>
                                <li><a href="#contructeurs-de-fonction">Contructeurs de fonction</a></li>
                                <li><a href="#fonctions-r%C3%A9cursives">Fonctions récursives</a></li>
                                <li><a href="#fonctions-de-rappel-callbacks">Fonctions de rappel (callbacks)</a></li>
                                <li><a href="#fonctions-de-rappel-asynchrones">Fonctions de rappel asynchrones</a></li>
                                <li><a href="#fonctions-de-rappel-avec-param%C3%A8tres">Fonctions de rappel avec
                                        paramètres</a></li>
                                <li><a href="#fonctions-de-rappel-avec-plusieurs-param%C3%A8tres">Fonctions de rappel
                                        avec plusieurs paramètres</a></li>
                                <li><a href="#fonctions-de-rappel-avec-une-valeur-de-retour">Fonctions de rappel avec
                                        une valeur de retour</a></li>
                            </ul>
                        </li>
                        <li><a href="#port%C3%A9e-des-variables">Portée des variables</a></li>
                        <li><a href="#fermetures-closures">Fermetures (Closures)</a></li>
                    </ul>
                </li>
                <li><a href="#callbacks-et-promesses">Callbacks et promesses</a>
                    <ul>
                        <li><a href="#callbacks">Callbacks</a></li>
                    </ul>
                </li>
                <li><a href="#promesses">Promesses</a></li>
                <li><a href="#programmation-orient%C3%A9e-objet-poo">Programmation Orientée Objet (POO)</a>
                    <ul>
                        <li><a href="#objets-et-propri%C3%A9t%C3%A9s">Objets et propriétés</a></li>
                        <li><a href="#constructeurs-et-prototypes">Constructeurs et prototypes</a></li>
                        <li><a href="#h%C3%A9ritage-et-polymorphisme">Héritage et polymorphisme</a></li>
                        <li><a href="#es6-classes">ES6 Classes</a></li>
                        <li><a href="#encapsulation-et-abstraction">Encapsulation et abstraction</a></li>
                    </ul>
                </li>
                <li><a href="#manipulation-du-dom">Manipulation du DOM</a>
                    <ul>
                        <li><a href="#s%C3%A9lection-d%C3%A9l%C3%A9ments">Sélection d'éléments</a>
                            <ul>
                                <li><a href="#m%C3%A9thodes-de-s%C3%A9lection-d%C3%A9l%C3%A9ments">Méthodes de sélection
                                        d'éléments</a></li>
                                <li><a href="#s%C3%A9lection-d%C3%A9l%C3%A9ments-imbriqu%C3%A9s">Sélection d'éléments
                                        imbriqués</a></li>
                            </ul>
                        </li>
                        <li><a href="#modification-du-contenu">Modification du contenu</a></li>
                        <li><a href="#gestion-des-%C3%A9v%C3%A9nements">Gestion des événements</a>
                            <ul>
                                <li><a href="#ajout-dun-gestionnaire-d%C3%A9v%C3%A9nements">Ajout d'un gestionnaire
                                        d'événements</a></li>
                                <li><a href="#suppression-dun-gestionnaire-d%C3%A9v%C3%A9nements">Suppression d'un
                                        gestionnaire d'événements</a></li>
                                <li><a href="#propagation-d%C3%A9v%C3%A9nements">Propagation d'événements</a></li>
                                <li><a href="#objet-event">Objet Event</a></li>
                            </ul>
                        </li>
                        <li><a
                                href="#types-d%C3%A9v%C3%A9nements--consulter-la-liste-compl%C3%A8te-des-%C3%A9v%C3%A9nements-sur-mdn">Types
                                d'événements : Consulter la liste complète des événements sur MDN</a>
                            <ul>
                                <li><a href="#%C3%A9v%C3%A9nements-de-souris">Événements de souris</a></li>
                            </ul>
                        </li>
                        <li><a href="#animation-et-effets-setinterval-et-settimeout">Animation et effets: setInterval et
                                setTimeout</a>
                            <ul>
                                <li><a href="#setinterval">setInterval</a></li>
                                <li><a href="#settimeout">setTimeout</a></li>
                            </ul>
                        </li>
                        <li><a href="#manipulation-du-css">Manipulation du CSS</a></li>
                    </ul>
                </li>
                <li><a href="#%C3%A9v%C3%A9nements-et-gestionnaires-d%C3%A9v%C3%A9nements">Événements et gestionnaires
                        d'événements</a>
                    <ul>
                        <li><a href="#%C3%A9couteurs-d%C3%A9v%C3%A9nements">Écouteurs d'événements</a></li>
                        <li><a href="#%C3%A9v%C3%A9nements-de-formulaire">Événements de formulaire</a></li>
                        <li><a href="#propagation-des-%C3%A9v%C3%A9nements">Propagation des événements</a></li>
                    </ul>
                </li>
                <li><a href="#traitement-asynchrone-en-javascript">Traitement asynchrone en JavaScript</a>
                    <ul>
                        <li><a href="#promesses-et-asyncawait">Promesses et async/await</a></li>
                        <li><a href="#ajax-et-fetch-api">AJAX et Fetch API</a></li>
                        <li><a href="#websockets-et-communication-en-temps-r%C3%A9el">WebSockets et communication en
                                temps réel</a></li>
                    </ul>
                </li>
                <li><a href="#frameworks-et-biblioth%C3%A8ques-populaires">Frameworks et bibliothèques populaires</a>
                    <ul>
                        <li><a href="#vuejs">Vue.js</a></li>
                        <li><a href="#react">React</a></li>
                        <li><a href="#angular">Angular</a></li>
                        <li><a href="#backend-frameworks-ex-nestjs-meteor">Backend frameworks (ex: Nest.js, Meteor)</a>
                        </li>
                    </ul>
                </li>
                <li><a href="#bonnes-pratiques-et-s%C3%A9curit%C3%A9">Bonnes pratiques et sécurité</a>
                    <ul>
                        <li><a href="#%C3%A9criture-de-code-maintenable">Écriture de code maintenable</a></li>
                        <li><a href="#outils-de-d%C3%A9bogage">Outils de débogage</a></li>
                        <li><a href="#pr%C3%A9vention-des-vuln%C3%A9rabilit%C3%A9s-courantes">Prévention des
                                vulnérabilités courantes</a></li>
                    </ul>
                </li>
                <li><a href="#annexes">Annexes</a>
                    <ul>
                        <li><a href="#ressources-suppl%C3%A9mentaires">Ressources supplémentaires</a></li>
                        <li><a href="#glossaire">Glossaire</a></li>
                        <li><a href="#r%C3%A9f%C3%A9rences">Références</a></li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <h2 id="toc"><!-- TOC --></h2>
    <h2 id="introduction-au-javascript">Introduction au JavaScript</h2>
    <p>JavaScript, souvent abrégé en JS, est un langage de programmation qui, à l'origine, a été conçu pour rendre les
        pages web interactives et dynamiques. Depuis sa création en 1995 par Brendan Eich alors qu'il était employé chez
        Netscape Communications Corporation, JavaScript a parcouru un long chemin. Aujourd'hui, il ne se limite pas
        uniquement au navigateur web : il est également utilisé côté serveur, pour le développement d'applications
        mobiles, de jeux et bien d'autres domaines.</p>
    <p>Contrairement à ce que son nom pourrait suggérer, JavaScript n'a pas de lien direct avec le langage Java. La
        similarité des noms est davantage due à des raisons marketing de l'époque qu'à une quelconque ressemblance
        technique entre les deux langages.</p>
    <p>Une des forces majeures de JavaScript est son caractère universel. Presque tous les navigateurs web modernes
        supportent JavaScript, ce qui en fait l'un des outils les plus accessibles pour améliorer l'expérience
        utilisateur sur le web. Avec l'avènement de technologies comme Node.js, il est également devenu un acteur majeur
        dans le développement côté serveur, permettant aux développeurs de travailler avec un seul langage à la fois
        pour le client et le serveur.</p>
    <p>En plus de sa flexibilité, JavaScript est un langage qui est continuellement en évolution. Avec l'introduction
        d'ECMAScript (ES6, ES7...), de nouvelles fonctionnalités sont régulièrement ajoutées, rendant le langage encore
        plus puissant et expressif.</p>
    <p>L'apprentissage de JavaScript est essentiel pour quiconque souhaite devenir un développeur web complet. Qu'il
        s'agisse de créer de simples animations sur une page, de développer des applications web complexes ou même des
        applications serveur, JavaScript se trouve au cœur de la plupart des interactions numériques modernes.</p>
    <p>Dans cette formation, nous allons explorer les fondamentaux du langage, découvrir comment il s'intègre dans
        l'écosystème web et, enfin, plonger dans des concepts avancés qui sont devenus des standards de l'industrie.
        Alors, préparez-vous pour un voyage passionnant dans le monde de JavaScript !</p>
    <h3 id="historique-et-%C3%A9volution-de-javascript">Historique et évolution de JavaScript</h3>
    <p>JavaScript a été créé en 1995 par Brendan Eich, alors employé chez Netscape Communications Corporation. À
        l'époque, Netscape était le navigateur web le plus populaire, mais il ne disposait pas d'un langage de script
        pour rendre les pages web interactives. C'est pourquoi Brendan Eich a été engagé pour créer un langage de script
        pour le navigateur Netscape Navigator.</p>
    <p>Historique et évolution de JavaScript</p>
    <ul>
        <li>
            <p><strong>1995 : Naissance de JavaScript</strong></p>
            <p>Brendan Eich, alors employé chez Netscape Communications Corporation, conçoit le langage en seulement dix
                jours. À l'origine, le langage est appelé Mocha, puis renommé LiveScript, avant d'adopter le nom
                JavaScript, principalement pour des raisons marketing en lien avec la popularité du langage Java à cette
                époque.</p>
        </li>
        <li>
            <p><strong>1996-1997 : Adoption et standardisation</strong></p>
            <p>Microsoft crée une version similaire pour son navigateur Internet Explorer, nommée JScript, afin d'éviter
                les problèmes de licence avec Netscape.
                Devant l'adoption rapide et l'utilisation croissante du langage, Netscape le soumet à l'ECMA
                International pour le standardiser. La première édition du standard, nommé ECMAScript, est publiée en
                1997.</p>
        </li>
        <li>
            <p><strong>1999 : ECMAScript 3</strong></p>
            <p>La troisième édition de ECMAScript est publiée, introduisant de nombreuses fonctionnalités qui définiront
                le cœur du langage pendant plus d'une décennie.</p>
        </li>
        <li>
            <p><strong>2000-2005 : L'ère des ajouts et des frameworks</strong></p>
            <p>Alors que la quatrième édition d'ECMAScript est abandonnée en raison de désaccords sur son contenu,
                JavaScript continue de croître en popularité. C'est durant cette période que des bibliothèques comme
                jQuery voient le jour, simplifiant le développement et masquant les incompatibilités entre navigateurs.
            </p>
        </li>
        <li>
            <p><strong>2009 : ECMAScript 5 (ES5)</strong></p>
            <p>Après une longue attente, ES5 est publié avec des fonctionnalités majeures comme les &quot;strict
                mode&quot;, les getters et setters, et les méthodes natives JSON.</p>
        </li>
        <li>
            <p><strong>2015 : ECMAScript 2015 (ES6)</strong></p>
            <p>Un tournant majeur pour JavaScript. ES6 (aussi appelé ES2015) introduit une multitude de nouvelles
                fonctionnalités, notamment les classes, les modules, les fonctions fléchées, les promesses, et bien plus
                encore. C'est aussi le début d'un engagement à mettre à jour le standard chaque année.</p>
        </li>
        <li>
            <p><strong>2016-2020 : Mises à jour annuelles</strong></p>
            <p>L'ECMA International commence à publier des mises à jour annuelles de la spécification. Chaque année, de
                nouvelles fonctionnalités sont ajoutées, comme les opérateurs de propagation (2018), les méthodes
                flatMap et flat pour les tableaux (2019), et l'opérateur de chaînage optionnel (2020).</p>
        </li>
        <li>
            <p><strong>Aujourd'hui :</strong></p>
            <p>JavaScript est omniprésent, s'exécutant non seulement dans les navigateurs, mais aussi sur les serveurs,
                les appareils IoT, et d'autres plateformes. Des frameworks et bibliothèques tels que React, Angular,
                Vue, et Node.js, propulsent JavaScript au rang de l'un des langages de programmation les plus populaires
                et les plus utilisés au monde.</p>
        </li>
    </ul>
    <p>L'évolution de JavaScript illustre l'adaptabilité et la robustesse d'un langage né d'un besoin de rendre le web
        plus interactif. Aujourd'hui, sa portée dépasse largement le cadre des navigateurs, témoignant de son rôle
        central dans l'écosystème technologique moderne.</p>
    <h3 id="pourquoi-utiliser-javascript">Pourquoi utiliser JavaScript ?</h3>
    <p>JavaScript est l'un des piliers du développement web et possède plusieurs atouts qui en font un choix
        incontournable pour les développeurs. Voici quelques raisons principales pour lesquelles vous devriez envisager
        d'utiliser JavaScript :</p>
    <ol>
        <li>
            <p><strong>Interactivité en temps réel :</strong> JavaScript permet d'ajouter des éléments interactifs à une
                page web, améliorant ainsi l'expérience utilisateur. Que ce soit pour des animations, des formulaires
                réactifs ou des mises à jour dynamiques, JavaScript est le moteur derrière l'interactivité sur le web.
            </p>
        </li>
        <li>
            <p><strong>Prise en charge universelle :</strong> Tous les navigateurs modernes supportent JavaScript. Cela
                signifie que sans avoir besoin de plugins ou d'extensions supplémentaires, vous pouvez écrire du code
                qui fonctionnera sur l'ensemble des plateformes.</p>
        </li>
        <li>
            <p><strong>Écosystème riche :</strong> La communauté JavaScript est l'une des plus actives. De nombreux
                frameworks, bibliothèques et outils ont été développés pour faciliter la tâche des développeurs. React,
                Angular, Vue, et Node.js ne sont que quelques exemples parmi tant d'autres.</p>
        </li>
        <li>
            <p><strong>Full Stack :</strong> Avec Node.js, JavaScript s'est étendu du navigateur au serveur. Cela
                signifie qu'un développeur peut utiliser JavaScript à la fois pour le front-end et le back-end de son
                application, favorisant ainsi une cohérence dans le code et une courbe d'apprentissage réduite.</p>
        </li>
        <li>
            <p><strong>Performances :</strong> Les moteurs JavaScript modernes, comme V8 (utilisé par Chrome et
                Node.js), sont extrêmement rapides, permettant des applications web aussi performantes que des
                applications natives.</p>
        </li>
        <li>
            <p><strong>Adaptable et évolutif :</strong> De simples scripts à de vastes applications d'entreprise,
                JavaScript peut être utilisé pour tout type de projet. Sa flexibilité en fait un choix solide pour une
                variété d'applications.</p>
        </li>
        <li>
            <p><strong>Communauté et soutien :</strong> Avec sa popularité grandissante, il existe une énorme communauté
                autour de JavaScript. Que vous cherchiez des solutions à des problèmes, des formations ou des
                partenaires de codage, la communauté JavaScript est active et prête à aider.</p>
        </li>
        <li>
            <p><strong>Progression constante :</strong> Grâce aux mises à jour annuelles d'ECMAScript, le langage
                continue d'évoluer et d'adopter de nouvelles fonctionnalités, garantissant qu'il reste moderne et
                pertinent.</p>
        </li>
    </ol>
    <p>En conclusion, JavaScript est non seulement un choix populaire, mais c'est aussi un outil puissant et flexible
        qui répond aux besoins des développeurs modernes. Que vous soyez débutant en développement ou un vétéran de
        l'industrie, les compétences en JavaScript sont essentielles pour naviguer dans le paysage technologique actuel.
    </p>
    <h3 id="diff%C3%A9rence-entre-java-et-javascript">Différence entre Java et JavaScript</h3>
    <p>Bien que leurs noms soient similaires, Java et JavaScript sont deux langages de programmation distincts avec des
        différences majeures en termes de conception, d'utilisation et de fonctionnalités. Voici une comparaison
        détaillée :</p>
    <ol>
        <li>
            <p><strong>Origine et Histoire</strong> :</p>
            <ul>
                <li><strong>Java</strong> a été développé par Sun Microsystems (maintenant propriété d'Oracle) dans les
                    années 1990. Il visait à être un langage orienté objet &quot;write once, run anywhere&quot;.</li>
                <li><strong>JavaScript</strong> a été créé par Brendan Eich pour Netscape en 1995 pour donner vie aux
                    pages web et les rendre interactives.</li>
            </ul>
        </li>
        <li>
            <p><strong>Exécution</strong> :</p>
            <ul>
                <li><strong>Java</strong> est un langage compilé. Le code Java est transformé en bytecode par un
                    compilateur, et ce bytecode est ensuite exécuté par la machine virtuelle Java (JVM).</li>
                <li><strong>JavaScript</strong> est un langage interprété. Il est exécuté ligne par ligne, à la volée,
                    principalement par les moteurs JavaScript des navigateurs web.</li>
            </ul>
        </li>
        <li>
            <p><strong>Domaine d'application</strong> :</p>
            <ul>
                <li><strong>Java</strong> est principalement utilisé pour le développement d'applications d'entreprise,
                    d'applications mobiles (Android), de systèmes embarqués et d'applications de bureau.</li>
                <li><strong>JavaScript</strong> a été initialement conçu pour le web, mais avec l'arrivée de Node.js, il
                    est maintenant utilisé aussi bien côté client (front-end) que côté serveur (back-end).</li>
            </ul>
        </li>
        <li>
            <p><strong>Syntaxe et Conception</strong> :</p>
            <ul>
                <li>Bien que leurs syntaxes puissent partager certaines similitudes (dues à leur héritage commun de C),
                    leurs philosophies et structures sont différentes.</li>
                <li><strong>Java</strong> est fortement typé et orienté objet.</li>
                <li><strong>JavaScript</strong> est dynamiquement typé et, bien qu'il prenne en charge la programmation
                    orientée objet, il est basé sur des prototypes.</li>
            </ul>
        </li>
        <li>
            <p><strong>Concurrence</strong> :</p>
            <ul>
                <li><strong>Java</strong> utilise des threads pour gérer la concurrence.</li>
                <li><strong>JavaScript</strong> utilise un modèle d'exécution à thread unique avec une boucle
                    d'événements, ce qui le rend non bloquant.</li>
            </ul>
        </li>
        <li>
            <p><strong>Portabilité</strong> :</p>
            <ul>
                <li><strong>Java</strong> est connu pour sa promesse &quot;write once, run anywhere&quot; (écrivez une
                    fois, exécutez partout), grâce à la JVM.</li>
                <li><strong>JavaScript</strong> est nativement supporté par tous les navigateurs modernes, le rendant
                    universellement disponible pour le développement web.</li>
            </ul>
        </li>
        <li>
            <p><strong>Interactivité et Intégration</strong> :</p>
            <ul>
                <li><strong>Java</strong> peut être intégré dans les pages web à travers des applets, bien que cette
                    pratique soit largement obsolète.</li>
                <li><strong>JavaScript</strong> est intégré directement dans les navigateurs web et est essentiel pour
                    le développement web interactif.</li>
            </ul>
        </li>
        <li>
            <p><strong>Performance</strong> :</p>
            <ul>
                <li><strong>Java</strong> est généralement plus rapide en exécution car il est compilé en bytecode,
                    optimisé pour la JVM.</li>
                <li><strong>JavaScript</strong> dépend du moteur JavaScript du navigateur ou de l'environnement
                    d'exécution, mais avec les optimisations modernes, il peut être extrêmement rapide.</li>
            </ul>
        </li>
        <li>
            <p><strong>Ecosystèmes et outils</strong> :</p>
            <ul>
                <li><strong>Java</strong> dispose d'un large écosystème avec des frameworks tels que Spring, Hibernate,
                    JavaFX et d'autres.</li>
                <li><strong>JavaScript</strong> a une multitude de bibliothèques et de frameworks tels que React,
                    Angular, Vue, Node.js, etc.</li>
            </ul>
        </li>
    </ol>
    <p>En conclusion, malgré leurs noms similaires, Java et JavaScript sont fondamentalement différents et servent des
        objectifs différents dans le monde de la programmation. Comparer Java à JavaScript, c'est un peu comme comparer
        des voitures à des vélos; bien qu'ils puissent partager certaines fonctions (comme le transport), leurs
        utilisations, leurs caractéristiques et leurs mécanismes internes sont profondément différents.</p>
    <h3 id="environnement-dex%C3%A9cution-javascript">Environnement d'exécution JavaScript</h3>
    <p>L'environnement d'exécution est l'endroit où le code est exécuté. Dans le contexte de JavaScript, il est
        essentiel de comprendre qu'il ne se limite pas à un navigateur. Voici un aperçu des environnements d'exécution
        courants de JavaScript :</p>
    <ol>
        <li><strong>Navigateur Web (Front-end)</strong>:</li>
    </ol>
    <ul>
        <li>L'environnement le plus courant pour JavaScript est le navigateur web. Presque tous les navigateurs modernes
            possèdent un moteur JavaScript intégré pour interpréter et exécuter le code JavaScript. Des exemples de ces
            moteurs sont V8 (Google Chrome), SpiderMonkey (Firefox), Chakra (Microsoft Edge), et JavaScriptCore
            (Safari).</li>
        <li>Dans le navigateur, JavaScript a accès à l'objet global <code>window</code>, au Document Object Model (DOM)
            pour manipuler les éléments de la page, et à d'autres API Web telles que Fetch pour les requêtes réseau.
        </li>
    </ul>
    <ol start="2">
        <li><strong>Serveur (Back-end avec Node.js)</strong>:</li>
    </ol>
    <ul>
        <li><a href="https://nodejs.org/">Node.js</a> est une plateforme d'exécution côté serveur basée sur le moteur V8
            de Chrome qui permet d'exécuter JavaScript hors du navigateur. C'est l'une des plateformes les plus
            populaires pour le développement backend avec JavaScript.</li>
        <li>Avec Node.js, JavaScript a accès à l'objet global <code>global</code>, au système de fichiers via le module
            <code>fs</code>, et peut effectuer des opérations réseau, entre autres.
        </li>
    </ul>
    <ol start="3">
        <li><strong>Applications Mobiles</strong>:</li>
    </ol>
    <ul>
        <li>Des frameworks tels que <a href="https://reactnative.dev/">React Native</a> ou <a
                href="https://www.nativescript.org/">NativeScript</a> permettent de développer des applications mobiles
            natives en utilisant JavaScript.</li>
    </ul>
    <ol start="4">
        <li><strong>Applications de Bureau</strong>:</li>
    </ol>
    <ul>
        <li><a href="https://www.electronjs.org/">Electron</a> est un framework qui permet de créer des applications de
            bureau multiplateformes avec JavaScript, HTML et CSS. Il combine Node.js et Chromium pour fournir un
            environnement riche pour les applications de bureau.</li>
    </ul>
    <ol start="5">
        <li><strong>Environnements IoT (Internet des Objets)</strong> :</li>
    </ol>
    <ul>
        <li>JavaScript peut également être exécuté sur des dispositifs IoT (comme des microcontrôleurs) grâce à des
            plateformes comme <a href="https://jerryscript.net/">JerryScript</a> ou <a
                href="https://www.espruino.com/">Espruino</a>.</li>
    </ul>
    <ol start="6">
        <li><strong>Autres environnements</strong> :</li>
    </ol>
    <ul>
        <li>JavaScript peut également être exécuté dans des environnements tels que des bases de données (comme MongoDB
            qui utilise JavaScript pour ses fonctions d'agrégation) ou sur des plateformes cloud comme les fonctions AWS
            Lambda.</li>
    </ul>
    <h3 id="outils-de-d%C3%A9veloppement">Outils de développement</h3>
    <p>Il existe de nombreux outils qui améliorent et facilitent le développement en JavaScript :</p>
    <ol>
        <li>
            <p><strong>Consoles de Développeur</strong> : Intégrées à la plupart des navigateurs modernes, elles
                permettent de déboguer, profiler et inspecter le code JavaScript en temps réel.</p>
        </li>
        <li>
            <p><strong>Bundlers &amp; Task Runners</strong> : Outils comme Webpack, Rollup, Grunt, et Gulp permettent
                d'automatiser les tâches, de gérer les dépendances et de packager le code.</p>
        </li>
        <li>
            <p><strong>Transpilers</strong> : Babel est un exemple populaire qui permet de transformer le code
                JavaScript moderne (ES6/ESNext) en code ES5 compatible avec les anciens navigateurs.</p>
        </li>
        <li>
            <p><strong>Linteurs</strong> : Outils comme ESLint et TSLint aident à identifier et corriger les problèmes
                dans le code.</p>
        </li>
        <li>
            <p><strong>Environnements de Test</strong> : Frameworks comme Jest, Mocha, et Jasmine offrent des moyens
                d'écrire des tests pour le code JavaScript.</p>
        </li>
    </ol>
    <p>L'écosystème JavaScript est vaste et en constante évolution. La clé est de trouver les outils et environnements
        qui correspondent le mieux à vos besoins spécifiques de développement.</p>
    <h2 id="bases-du-javascript">Bases du JavaScript</h2>
    <p>Dans cette section, nous allons explorer les bases du langage JavaScript. Nous allons commencer par les
        fondamentaux, puis nous allons plonger dans les types de données, les variables, les opérateurs, les structures
        conditionnelles et les boucles.</p>
    <h3 id="syntaxe-de-base">Syntaxe de base</h3>
    <p>La syntaxe d'un langage de programmation est un ensemble de règles qui définissent comment le code doit être
        écrit et structuré. La syntaxe de JavaScript est basée sur le langage C, mais elle a évolué au fil du temps pour
        inclure des fonctionnalités supplémentaires.</p>
    <p>Voici quelques règles de base à garder à l'esprit lors de l'écriture de code JavaScript :</p>
    <ul>
        <li><strong>Sensibilité à la casse</strong> : JavaScript est sensible à la casse, ce qui signifie que les
            variables <code>name</code> et <code>Name</code> sont considérées comme différentes.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> name = <span class="hljs-string">"John"</span>;
    <span class="hljs-keyword">let</span> Name = <span class="hljs-string">"Jane"</span>;
    </div></code></pre>
    <p>Dans l'exemple ci-dessus, <code>name</code> et <code>Name</code> sont deux variables différentes.</p>
    <ul>
        <li><strong>Sensibilité aux espaces</strong> : JavaScript ignore les espaces, les tabulations et les sauts de
            ligne qui ne sont pas à l'intérieur de chaînes de caractères ou de commentaires.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> name = <span class="hljs-string">"John"</span>;
    <span class="hljs-keyword">let</span> name = <span class="hljs-string">"Jane"</span>;
    </div></code></pre>
    <p>Dans l'exemple ci-dessus, les deux lignes sont identiques pour JavaScript.</p>
    <ul>
        <li>
            <p><strong>Commentaires</strong> : Les commentaires sont utilisés pour rendre le code plus lisible et ne
                sont pas exécutés. Il existe deux types de commentaires en JavaScript :</p>
            <ul>
                <li>
                    <p>Commentaires sur une ligne : <code>// ...</code></p>
                    <pre class="hljs"><code><div><span class="hljs-comment">// Ceci est un commentaire sur une ligne</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello World!"</span>);
    </div></code></pre>
                </li>
                <li>
                    <p>Commentaires sur plusieurs lignes : <code>/* ... */</code></p>
                    <pre class="hljs"><code><div><span class="hljs-comment">/*
    * Ceci est un commentaire sur plusieurs lignes
    */</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello World!"</span>);
    </div></code></pre>
                </li>
                <li>
                    <p>Les commentaires sur plusieurs lignes peuvent être imbriqués. Cependant, il y a une particularité
                        avec les commentaires sur plusieurs lignes en JavaScript : ils ne peuvent pas être imbriqués de
                        manière native.</p>
                    <ul>
                        <li><strong>De manière native :</strong></li>
                    </ul>
                    <pre class="hljs"><code><div><span class="hljs-comment">/* Ceci est un commentaire sur plusieurs lignes
    /* qui contient un autre commentaire sur plusieurs lignes */</span>
    *<span class="hljs-regexp">/
    console.log('Hello World!');
    </span></div></code></pre>
                    <p>Le code ci-dessus générera une erreur de syntaxe.</p>
                    <ul>
                        <li>Contournement :</li>
                    </ul>
                    <pre class="hljs"><code><div><span class="hljs-comment">/* Ceci est un commentaire sur plusieurs lignes
    // qui contient un autre commentaire sur plusieurs lignes
    */</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello World!"</span>);
    </div></code></pre>
                    <p>Notez que l'utilisation de <code>//</code> à l'intérieur d'un bloc commenté avec
                        <code>/* ... */</code> n'a pas d'effet réel sur le comportement du commentaire, mais cela peut
                        être utile pour la lisibilité ou pour marquer temporairement certaines parties du commentaire.
                    </p>
                </li>
            </ul>
            <p>En résumé, les commentaires imbriqués ne sont pas directement supportés en JavaScript, mais il y a des
                méthodes pour contourner cette limitation si nécessaire.</p>
        </li>
        <li>
            <p><strong>Point-virgule</strong> : En JavaScript, le point-virgule (<code>;</code>) est utilisé pour
                séparer les instructions. Cependant, son utilisation présente des particularités qui méritent d'être
                soulignées.</p>
            <ul>
                <li>
                    <p>Utilisation facultative (la plupart du temps) :
                        Grâce à une fonctionnalité appelée &quot;Insertion automatique de point-virgule&quot; (Automatic
                        Semicolon Insertion - ASI), JavaScript insère automatiquement des points-virgules à la fin des
                        instructions dans la plupart des situations où ils sont omis.</p>
                    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;
    <span class="hljs-built_in">console</span>.log(a + b);
    </div></code></pre>
                    <p>Dans cet exemple, même si aucun point-virgule n'est présent, le code fonctionnera correctement,
                        car l'ASI insérera automatiquement des points-virgules à la fin de chaque instruction.</p>
                    <ul>
                        <li><strong>Style et lisibilité :</strong> L'utilisation explicite de points-virgules peut
                            rendre le code plus lisible pour d'autres développeurs, en particulier pour ceux qui
                            viennent d'autres langages où les points-virgules sont obligatoires. Il est donc recommandé
                            d'utiliser des points-virgules dans votre code, même si ce n'est pas strictement nécessaire.
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <p><strong>Conseil général :</strong> Que vous choisissiez d'utiliser ou non des points-virgules, l'important est
        d'être cohérent tout au long de votre code. Certains guides de style recommandent toujours l'utilisation de
        points-virgules, tandis que d'autres sont plus flexibles. Utilisez celui qui convient le mieux à votre équipe ou
        à votre projet.</p>
    <p>En conclusion, bien que l'ASI rende les points-virgules optionnels dans de nombreux cas en JavaScript, il est
        souvent recommandé de les utiliser explicitement pour éviter toute confusion ou erreur potentielle.</p>
    <h3 id="types-de-donn%C3%A9es">Types de données</h3>
    <p>Les types de données sont les différents types de valeurs que peut contenir une variable. JavaScript est un
        langage dynamiquement typé, ce qui signifie que les variables peuvent contenir des valeurs de différents types
        sans avoir besoin de les déclarer explicitement. Il existe sept types de données primitifs en JavaScript :</p>
    <ol>
        <li><strong>Number</strong> : Les nombres sont utilisés pour représenter des valeurs numériques. Ils peuvent
            être entiers ou à virgule flottante. Les nombres peuvent être créés en utilisant la syntaxe littérale ou en
            utilisant le constructeur <code>Number()</code>.</li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// entier</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// à virgule flottante</span>
    <span class="hljs-keyword">let</span> c = <span class="hljs-built_in">Number</span>(<span class="hljs-string">"5"</span>); <span class="hljs-comment">// entier</span>
    <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">Number</span>(<span class="hljs-string">"3.14"</span>); <span class="hljs-comment">// à virgule flottante</span>
    </div></code></pre>
    <ol start="2">
        <li><strong>String</strong> : Les chaînes de caractères sont utilisées pour représenter des valeurs textuelles.
            Elles peuvent être créées en utilisant la syntaxe littérale ou en utilisant le constructeur
            <code>String()</code>.
        </li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// avec des guillemets simples</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// avec des guillemets doubles</span>
    <span class="hljs-keyword">let</span> c = <span class="hljs-built_in">String</span>(<span class="hljs-string">"Hello World!"</span>); <span class="hljs-comment">// avec le constructeur String()</span>
    </div></code></pre>
    <ol start="3">
        <li><strong>Boolean</strong> : Les booléens sont utilisés pour représenter des valeurs logiques. Ils peuvent
            être soit <code>true</code> (vrai) soit <code>false</code> (faux). Les booléens peuvent être créés en
            utilisant la syntaxe littérale ou en utilisant le constructeur <code>Boolean()</code>.</li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-literal">true</span>; <span class="hljs-comment">// vrai</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-literal">false</span>; <span class="hljs-comment">// faux</span>
    <span class="hljs-keyword">let</span> c = <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">"true"</span>); <span class="hljs-comment">// vrai</span>
    <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">"false"</span>); <span class="hljs-comment">// vrai</span>
    </div></code></pre>
    <ol start="4">
        <li><strong>Null</strong> : Null est utilisé pour représenter l'absence de valeur. Il peut être créé en
            utilisant la syntaxe littérale ou en utilisant le mot-clé <code>null</code>.</li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>; <span class="hljs-comment">// null</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-literal">null</span>; <span class="hljs-comment">// null</span>
    </div></code></pre>
    <ol start="5">
        <li><strong>Undefined</strong> : Undefined est utilisé pour représenter une variable qui n'a pas été
            initialisée. Il peut être créé en utilisant la syntaxe littérale ou en utilisant le mot-clé
            <code>undefined</code>.
        </li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a; <span class="hljs-comment">// undefined</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// undefined</span>
    </div></code></pre>
    <ol start="6">
        <li><strong>Symbol</strong> : Les symboles sont utilisés pour créer des identifiants uniques. Ils peuvent être
            créés en utilisant la syntaxe littérale ou en utilisant le constructeur <code>Symbol()</code>.</li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">Symbol</span>(); <span class="hljs-comment">// symbole unique</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Symbol</span>(); <span class="hljs-comment">// symbole unique</span>
    </div></code></pre>
    <ol start="7">
        <li><strong>BigInt</strong> : BigInt est utilisé pour représenter des entiers de taille arbitraire. Il peut être
            créé en utilisant la syntaxe littérale ou en utilisant le constructeur <code>BigInt()</code>.</li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">1234567890123456789012345678901234567890n</span>; <span class="hljs-comment">// entier de taille arbitraire</span>
    <span class="hljs-keyword">let</span> b = BigInt(<span class="hljs-string">"1234567890123456789012345678901234567890"</span>); <span class="hljs-comment">// entier de taille arbitraire</span>
    </div></code></pre>
    <p>En plus des types de données primitifs, JavaScript dispose également de deux types de données non primitifs :</p>
    <ol>
        <li><strong>Object</strong> : Les objets sont utilisés pour représenter des collections de données. Ils peuvent
            être créés en utilisant la syntaxe littérale ou en utilisant le constructeur <code>Object()</code>.</li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = {}; <span class="hljs-comment">// objet vide</span>
    <span class="hljs-keyword">let</span> b = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> }; <span class="hljs-comment">// objet avec des propriétés</span>
    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); <span class="hljs-comment">// objet vide</span>
    <span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> }); <span class="hljs-comment">// objet avec des propriétés</span>
    </div></code></pre>
    <ol start="2">
        <li><strong>Function</strong> : Les fonctions sont utilisées pour représenter des blocs de code réutilisables.
            Elles peuvent être créées en utilisant la syntaxe littérale ou en utilisant le mot-clé
            <code>function</code>.
        </li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// fonction anonyme</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a + b;
    }; <span class="hljs-comment">// fonction nommée</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a + b;
    } <span class="hljs-comment">// fonction nommée</span>
    </div></code></pre>
    <p>En conclusion, JavaScript est un langage dynamiquement typé, ce qui signifie que les variables peuvent contenir
        des valeurs de différents types sans avoir besoin de les déclarer explicitement. Il existe sept types de données
        primitifs en JavaScript : Number, String, Boolean, Null, Undefined, Symbol et BigInt. En plus des types de
        données primitifs, JavaScript dispose également de deux types de données non primitifs : Object et Function.</p>
    <h3 id="variables-et-constantes">Variables et constantes</h3>
    <p>Les variables sont utilisées pour stocker des valeurs dans la mémoire de l'ordinateur afin de pouvoir les
        utiliser plus tard dans le programme. Les variables sont déclarées en utilisant le mot-clé <code>let</code> ou
        <code>var</code> (déprécié) suivi du nom de la variable. Les variables peuvent être déclarées sans valeur
        initiale ou avec une valeur initiale. Voici quelques exemples :
    </p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a; <span class="hljs-comment">// déclaration d'une variable sans valeur initiale</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">5</span>; <span class="hljs-comment">// déclaration d'une variable avec une valeur initiale</span>
    </div></code></pre>
    <p>Les constantes sont similaires aux variables, à la différence qu'elles ne peuvent pas être réaffectées. Les
        constantes sont déclarées en utilisant le mot-clé <code>const</code> suivi du nom de la constante. Les
        constantes doivent être déclarées avec une valeur initiale. Voici quelques exemples :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// déclaration d'une constante avec une valeur initiale</span>
    </div></code></pre>
    <h3 id="affichage--consolelog-alert-et-prompt-documentwrite">Affichage : console.log(), alert() et prompt(),
        document.write()</h3>
    <p>En JavaScript, il existe plusieurs méthodes pour afficher des valeurs à l'écran. Les plus courantes sont
        <code>console.log()</code>, <code>alert()</code> et <code>prompt()</code>, <code>document.write()</code>.
    </p>
    <p>La fonction <code>console.log()</code> est utilisée pour afficher des valeurs dans la console du navigateur. Elle
        peut être utilisée pour afficher des variables, des constantes, des chaînes de caractères, des nombres, des
        booléens, des objets, des fonctions, etc. Voici quelques exemples :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// affiche 5</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello World!"</span>); <span class="hljs-comment">// affiche Hello World!</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span>); <span class="hljs-comment">// affiche true</span>
    <span class="hljs-built_in">console</span>.log({ <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> }); <span class="hljs-comment">// affiche { name: 'John', age: 30 }</span>
    </div></code></pre>
    <p>La fonction <code>alert()</code> est utilisée pour afficher des valeurs dans une boîte de dialogue. Elle peut
        être utilisée pour afficher des variables, des constantes, des chaînes de caractères, des nombres, des booléens,
        des objets, des fonctions, etc. Voici quelques exemples :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    alert(a); <span class="hljs-comment">// affiche 5</span>
    </div></code></pre>
    <p>La fonction <code>prompt()</code> est utilisée pour afficher une boîte de dialogue avec un champ de saisie. Elle
        peut être utilisée pour afficher des variables, des constantes, des chaînes de caractères, des nombres, des
        booléens, des objets, des fonctions, etc. Voici quelques exemples :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = prompt(<span class="hljs-string">"Entrez une valeur :"</span>);
    alert(a); <span class="hljs-comment">// affiche la valeur saisie</span>
    </div></code></pre>
    <p>La fonction <code>document.write()</code> est utilisée pour afficher des valeurs dans le document HTML. Elle peut
        être utilisée pour afficher des variables, des constantes, des chaînes de caractères, des nombres, des booléens,
        des objets, des fonctions, etc. Voici quelques exemples :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">document</span>.write(a); <span class="hljs-comment">// affiche 5</span>
    </div></code></pre>
    <p>En conclusion, il existe plusieurs méthodes pour afficher des valeurs à l'écran en JavaScript. Les plus courantes
        sont <code>console.log()</code>, <code>alert()</code> et <code>prompt()</code>, <code>document.write()</code>.
    </p>
    <h3 id="op%C3%A9rateurs">Opérateurs</h3>
    <p>Les opérateurs sont utilisés pour effectuer des opérations sur des variables et des valeurs. JavaScript dispose
        de nombreux opérateurs différents, mais nous allons nous concentrer sur les opérateurs les plus courants.</p>
    <h4 id="op%C3%A9rateurs-arithm%C3%A9tiques">Opérateurs arithmétiques</h4>
    <p>Les opérateurs arithmétiques sont utilisés pour effectuer des opérations mathématiques sur des variables et des
        valeurs. Voici une liste des opérateurs arithmétiques les plus courants :</p>
    <ul>
        <li><strong>Addition (+)</strong> : Additionne deux valeurs.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">// 7</span>
    alert(a); <span class="hljs-comment">// affiche 7</span>
    </div></code></pre>
    <ul>
        <li><strong>Soustraction (-)</strong> : Soustrait une valeur d'une autre.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span> - <span class="hljs-number">2</span>; <span class="hljs-comment">// 3</span>
    alert(a); <span class="hljs-comment">// affiche 3</span>
    </div></code></pre>
    <ul>
        <li><strong>Multiplication (*)</strong> : Multiplie deux valeurs.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span> * <span class="hljs-number">2</span>; <span class="hljs-comment">// 10</span>
    alert(a); <span class="hljs-comment">// affiche 10</span>
    </div></code></pre>
    <ul>
        <li><strong>Division (/)</strong> : Divise une valeur par une autre.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span> / <span class="hljs-number">2</span>; <span class="hljs-comment">// 2.5</span>
    alert(a); <span class="hljs-comment">// affiche 2.5</span>
    </div></code></pre>
    <ul>
        <li><strong>Modulo (%)</strong> : Divise une valeur par une autre et retourne le reste.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span> % <span class="hljs-number">2</span>; <span class="hljs-comment">// 1</span>
    alert(a); <span class="hljs-comment">// affiche 1</span>
    </div></code></pre>
    <ul>
        <li><strong>Incrémentation (++)</strong> : Incrémente une valeur de 1.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    a++; <span class="hljs-comment">// équivaut à a = a + 1;</span>
    alert(a); <span class="hljs-comment">// affiche 6</span>
    </div></code></pre>
    <ul>
        <li><strong>Décrémentation (--)</strong> : Décrémente une valeur de 1.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    a--; <span class="hljs-comment">// équivaut à a = a - 1;</span>
    alert(a); <span class="hljs-comment">// affiche 4</span>
    </div></code></pre>
    <h4 id="op%C3%A9rateurs-dassignation-----------et">Opérateurs d'assignation : <code>+</code>, <code>==</code>,
        <code>===</code>, <code>!=</code>, <code>!==</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>,
        <code>=&gt;</code> et <code>?</code> <code>:</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>
    </h4>
    <p>Les opérateurs d'assignation sont utilisés pour assigner des valeurs à des variables. Voici une liste des
        opérateurs d'assignation les plus courants :</p>
    <ul>
        <li><strong>Assignation (<code>=</code>)</strong> : Assigner une valeur à une variable.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// assigne 5 à la variable a</span>
    alert(a); <span class="hljs-comment">// affiche 5</span>
    </div></code></pre>
    <ul>
        <li><strong>Addition et assignation (<code>+=</code>)</strong> : Additionne une valeur à une variable et assigne
            le résultat à la variable.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    a += <span class="hljs-number">2</span>; <span class="hljs-comment">// équivaut à a = a + 2;</span>
    alert(a); <span class="hljs-comment">// affiche 7</span>
    </div></code></pre>
    <ul>
        <li><strong>Soustraction et assignation (<code>-=</code>)</strong> : Soustrait une valeur à une variable et
            assigne le résultat à la variable.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    a -= <span class="hljs-number">2</span>; <span class="hljs-comment">// équivaut à a = a - 2;</span>
    alert(a); <span class="hljs-comment">// affiche 3</span>
    </div></code></pre>
    <ul>
        <li><strong>Multiplication et assignation (<code>*=</code>)</strong> : Multiplie une valeur à une variable et
            assigne le résultat à la variable.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    a *= <span class="hljs-number">2</span>; <span class="hljs-comment">// équivaut à a = a * 2;</span>
    alert(a); <span class="hljs-comment">// affiche 10</span>
    </div></code></pre>
    <ul>
        <li><strong>Division et assignation (<code>/=</code>)</strong> : Divise une valeur à une variable et assigne le
            résultat à la variable.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    a /= <span class="hljs-number">2</span>; <span class="hljs-comment">// équivaut à a = a / 2;</span>
    alert(a); <span class="hljs-comment">// affiche 2.5</span>
    </div></code></pre>
    <ul>
        <li><strong>Modulo et assignation (<code>%=</code>)</strong> : Divise une valeur à une variable et assigne le
            reste à la variable.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    a %= <span class="hljs-number">2</span>; <span class="hljs-comment">// équivaut à a = a % 2;</span>
    alert(a); <span class="hljs-comment">// affiche 1</span>
    </div></code></pre>
    <ul>
        <li><strong>Incrémentation et assignation (<code>++</code>)</strong> : Incrémente une valeur à une variable et
            assigne le résultat à la variable.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    a++; <span class="hljs-comment">// équivaut à a = a + 1;</span>
    alert(a); <span class="hljs-comment">// affiche 6</span>
    </div></code></pre>
    <ul>
        <li><strong>Décrémentation et assignation (<code>--</code>)</strong> : Décrémente une valeur à une variable et
            assigne le résultat à la variable.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    a--; <span class="hljs-comment">// équivaut à a = a - 1;</span>
    alert(a); <span class="hljs-comment">// affiche 4</span>
    </div></code></pre>
    <ul>
        <li><strong>Assignation conditionnelle (<code>?</code> <code>:</code>)</strong> : Assigner une valeur à une
            variable en fonction d'une condition.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = a &gt; <span class="hljs-number">2</span> ? <span class="hljs-string">"a est supérieur à 2"</span> : <span class="hljs-string">"a est inférieur à 2"</span>;
    alert(b); <span class="hljs-comment">// affiche a est supérieur à 2</span>
    </div></code></pre>
    <ul>
        <li><strong>Assignation logique (<code>&amp;&amp;</code>)</strong> : Assigner une valeur à une variable en
            fonction de deux conditions.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = a &gt; <span class="hljs-number">2</span> &amp;&amp; a &lt; <span class="hljs-number">10</span>;
    alert(b); <span class="hljs-comment">// affiche true</span>
    </div></code></pre>
    <ul>
        <li><strong>Assignation logique (<code>||</code>)</strong> : Assigner une valeur à une variable en fonction
            d'une des deux conditions.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = a &gt; <span class="hljs-number">2</span> || a &lt; <span class="hljs-number">10</span>;
    alert(b); <span class="hljs-comment">// affiche true</span>
    </div></code></pre>
    <ul>
        <li><strong>Assignation logique (<code>!</code>)</strong> : Assigner une valeur à une variable en fonction d'une
            condition négative.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = !(a &gt; <span class="hljs-number">2</span>);
    alert(b); <span class="hljs-comment">// affiche false</span>
    </div></code></pre>
    <ul>
        <li><strong>Assignation logique (<code>??</code>)</strong> : Assigner une valeur à une variable en fonction
            d'une condition nulle.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> b = a ?? <span class="hljs-number">5</span>;
    alert(b); <span class="hljs-comment">// affiche 5</span>
    </div></code></pre>
    <ul>
        <li><strong>Assignation logique (<code>??=</code>)</strong> : Assigner une valeur à une variable en fonction
            d'une condition nulle.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>;
    a ??= <span class="hljs-number">5</span>;
    alert(a); <span class="hljs-comment">// affiche 5</span>
    </div></code></pre>
    <ul>
        <li><strong>Assignation logique (<code>||=</code>)</strong> : Assigner une valeur à une variable en fonction
            d'une condition nulle.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>;
    a ||= <span class="hljs-number">5</span>;
    alert(a); <span class="hljs-comment">// affiche 5</span>
    </div></code></pre>
    <ul>
        <li><strong>Assignation logique (<code>&amp;&amp;=</code>)</strong> : Assigner une valeur à une variable en
            fonction d'une condition nulle.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>;
    a &amp;&amp;= <span class="hljs-number">5</span>;
    alert(a); <span class="hljs-comment">// affiche null</span>
    </div></code></pre>
    <h4 id="op%C3%A9rateurs-de-comparaison">Opérateurs de comparaison</h4>
    <p>Les opérateurs de comparaison sont utilisés pour comparer des variables et des valeurs. Voici une liste des
        opérateurs de comparaison les plus courants :</p>
    <ul>
        <li><strong>Égalité (<code>==</code>)</strong> : Vérifie si deux valeurs sont égales.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">5</span>;
    alert(a == b); <span class="hljs-comment">// affiche true</span>
    </div></code></pre>
    <ul>
        <li><strong>Égalité stricte (<code>===</code>)</strong> : Vérifie si deux valeurs sont égales et du même type.
        </li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-string">"5"</span>;
    alert(a === b); <span class="hljs-comment">// affiche false</span>
    </div></code></pre>
    <ul>
        <li><strong>Inégalité (<code>!=</code>)</strong> : Vérifie si deux valeurs sont inégales.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">5</span>;
    alert(a != b); <span class="hljs-comment">// affiche false</span>
    </div></code></pre>
    <ul>
        <li><strong>Inégalité stricte (<code>!==</code>)</strong> : Vérifie si deux valeurs sont inégales ou de types
            différents.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-string">"5"</span>;
    alert(a !== b); <span class="hljs-comment">// affiche true</span>
    </div></code></pre>
    <ul>
        <li><strong>Supériorité (<code>&gt;</code>)</strong> : Vérifie si une valeur est supérieure à une autre.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;
    alert(a &gt; b); <span class="hljs-comment">// affiche true</span>
    </div></code></pre>
    <ul>
        <li><strong>Infériorité (<code>&lt;</code>)</strong> : Vérifie si une valeur est inférieure à une autre.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;
    alert(a &lt; b); <span class="hljs-comment">// affiche false</span>
    </div></code></pre>
    <ul>
        <li><strong>Supériorité ou égalité (<code>&gt;=</code>)</strong> : Vérifie si une valeur est supérieure ou égale
            à une autre.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;
    alert(a &gt;= b); <span class="hljs-comment">// affiche true</span>
    </div></code></pre>
    <ul>
        <li><strong>Infériorité ou égalité (<code>&lt;=</code>)</strong> : Vérifie si une valeur est inférieure ou égale
            à une autre.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;
    alert(a &lt;= b); <span class="hljs-comment">// affiche false</span>
    </div></code></pre>
    <h4 id="op%C3%A9rateurs-logiques">Opérateurs logiques</h4>
    <p>Les opérateurs logiques sont utilisés pour combiner des conditions. Voici une liste des opérateurs logiques les
        plus courants :</p>
    <ul>
        <li><strong>ET (<code>&amp;&amp;</code>)</strong> : Vérifie si deux conditions sont vraies.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;
    alert(a &gt; <span class="hljs-number">2</span> &amp;&amp; b &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// affiche false</span>
    </div></code></pre>
    <ul>
        <li><strong>OU (<code>||</code>)</strong> : Vérifie si une des deux conditions est vraie.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;
    alert(a &gt; <span class="hljs-number">2</span> || b &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// affiche true</span>
    </div></code></pre>
    <ul>
        <li><strong>NON (<code>!</code>)</strong> : Inverse le résultat d'une condition.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    alert(!(a &gt; <span class="hljs-number">2</span>)); <span class="hljs-comment">// affiche false</span>
    </div></code></pre>
    <h4 id="op%C3%A9rateurs-de-concat%C3%A9nation">Opérateurs de concaténation</h4>
    <p>Les opérateurs de concaténation sont utilisés pour concaténer des chaînes de caractères. Voici une liste des
        opérateurs de concaténation les plus courants :</p>
    <ul>
        <li><strong>Concaténation (<code>+</code>)</strong> : Concatène deux chaînes de caractères.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-string">"Hello"</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-string">"World"</span>;
    alert(a + <span class="hljs-string">" "</span> + b); <span class="hljs-comment">// affiche Hello World</span>
    </div></code></pre>
    <ul>
        <li><strong>Concaténation et assignation (<code>+=</code>)</strong> : Concatène une chaîne de caractères à une
            variable et assigne le résultat à la variable.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-string">"Hello"</span>;
    a += <span class="hljs-string">" World"</span>; <span class="hljs-comment">// équivaut à a = a + ' World';</span>
    alert(a); <span class="hljs-comment">// affiche Hello World</span>
    </div></code></pre>
    <h4 id="op%C3%A9rateurs-de-type">Opérateurs de type</h4>
    <p>Les opérateurs de type sont utilisés pour vérifier le type d'une variable ou d'une valeur. Voici une liste des
        opérateurs de type les plus courants :</p>
    <ul>
        <li><strong>Type de (<code>typeof</code>)</strong> : Vérifie le type d'une variable ou d'une valeur.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    alert(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">// affiche number</span>
    </div></code></pre>
    <ul>
        <li><strong>Instance de (<code>instanceof</code>)</strong> : Vérifie si un objet est une instance d'un
            constructeur.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">5</span>);
    alert(a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>); <span class="hljs-comment">// affiche true</span>
    </div></code></pre>
    <h4 id="op%C3%A9rateurs-de-bits">Opérateurs de bits</h4>
    <p>Les opérateurs de bits sont utilisés pour effectuer des opérations binaires sur des valeurs. Voici une liste des
        opérateurs de bits les plus courants :</p>
    <ul>
        <li><strong>ET (<code>&amp;</code>)</strong> : Effectue un ET binaire sur deux valeurs.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
    alert(a &amp; b); <span class="hljs-comment">// affiche 1</span>
    </div></code></pre>
    <ul>
        <li><strong>OU (<code>|</code>)</strong> : Effectue un OU binaire sur deux valeurs.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
    alert(a | b); <span class="hljs-comment">// affiche 5</span>
    </div></code></pre>
    <ul>
        <li><strong>OU exclusif (<code>^</code>)</strong> : Effectue un OU exclusif binaire sur deux valeurs.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
    alert(a ^ b); <span class="hljs-comment">// affiche 4</span>
    </div></code></pre>
    <ul>
        <li><strong>Décalage à gauche (<code>&lt;&lt;</code>)</strong> : Effectue un décalage à gauche binaire sur deux
            valeurs.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
    alert(a &lt;&lt; b); <span class="hljs-comment">// affiche 10</span>
    </div></code></pre>
    <ul>
        <li><strong>Décalage à droite (<code>&gt;&gt;</code>)</strong> : Effectue un décalage à droite binaire sur deux
            valeurs.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
    alert(a &gt;&gt; b); <span class="hljs-comment">// affiche 2</span>
    </div></code></pre>
    <ul>
        <li><strong>Décalage à droite non signé (<code>&gt;&gt;&gt;</code>)</strong> : Effectue un décalage à droite non
            signé binaire sur deux valeurs.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
    alert(a &gt;&gt;&gt; b); <span class="hljs-comment">// affiche 2</span>
    </div></code></pre>
    <ul>
        <li><strong>Négation (<code>~</code>)</strong> : Effectue une négation binaire sur une valeur.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    alert(~a); <span class="hljs-comment">// affiche -6</span>
    </div></code></pre>
    <h4 id="op%C3%A9rateurs-de-pr%C3%A9post-incr%C3%A9mentationd%C3%A9cr%C3%A9mentation">Opérateurs de
        pré/post-incrémentation/décrémentation</h4>
    <p>Les opérateurs de pré/post-incrémentation/décrémentation sont utilisés pour incrémenter ou décrémenter des
        variables. Voici une liste des opérateurs de pré/post-incrémentation/décrémentation les plus courants :</p>
    <ul>
        <li><strong>Pré-incrémentation (<code>++</code>)</strong> : Incrémente une valeur de 1 et retourne la valeur
            incrémentée.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    alert(++a); <span class="hljs-comment">// affiche 6</span>
    </div></code></pre>
    <ul>
        <li><strong>Post-incrémentation (<code>++</code>)</strong> : Incrémente une valeur de 1 et retourne la valeur
            originale.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    alert(a++); <span class="hljs-comment">// affiche 5</span>
    </div></code></pre>
    <ul>
        <li><strong>Pré-décrémentation (<code>--</code>)</strong> : Décrémente une valeur de 1 et retourne la valeur
            décrémentée.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    alert(--a); <span class="hljs-comment">// affiche 4</span>
    </div></code></pre>
    <ul>
        <li><strong>Post-décrémentation (<code>--</code>)</strong> : Décrémente une valeur de 1 et retourne la valeur
            originale.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    alert(a--); <span class="hljs-comment">// affiche 5</span>
    </div></code></pre>
    <h4 id="op%C3%A9rateurs-ternaires">Opérateurs ternaires</h4>
    <p>Les opérateurs ternaires sont utilisés pour effectuer des opérations conditionnelles. Voici une liste des
        opérateurs ternaires les plus courants :</p>
    <ul>
        <li><strong>Opérateur ternaire (<code>?</code> <code>:</code>)</strong> : Effectue une opération conditionnelle.
        </li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> b = a &gt; <span class="hljs-number">2</span> ? <span class="hljs-string">"a est supérieur à 2"</span> : <span class="hljs-string">"a est inférieur à 2"</span>;
    alert(b); <span class="hljs-comment">// affiche a est supérieur à 2</span>
    </div></code></pre>
    <h4 id="op%C3%A9rateurs-de-d%C3%A9composition">Opérateurs de décomposition</h4>
    <p>Les opérateurs de décomposition sont utilisés pour décomposer des objets ou des tableaux. Voici une liste des
        opérateurs de décomposition les plus courants :</p>
    <ul>
        <li><strong>Décomposition d'objet (<code>...</code>)</strong> : Décompose un objet en une liste de paramètres.
        </li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };
    <span class="hljs-keyword">let</span> b = { ...a };
    alert(b); <span class="hljs-comment">// affiche { name: 'John', age: 30 }</span>
    </div></code></pre>
    <ul>
        <li><strong>Décomposition de tableau (<code>...</code>)</strong> : Décompose un tableau en une liste de
            paramètres.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-keyword">let</span> b = [...a];
    alert(b); <span class="hljs-comment">// affiche [1, 2, 3]</span>
    </div></code></pre>
    <p>En conclusion, les opérateurs sont utilisés pour effectuer des opérations sur des variables et des valeurs.
        JavaScript dispose de nombreux opérateurs différents, mais nous allons nous concentrer sur les opérateurs les
        plus courants.</p>
    <h3 id="structures-conditionnelles">Structures conditionnelles</h3>
    <p>Les structures conditionnelles sont utilisées pour exécuter des blocs de code en fonction de conditions.
        JavaScript dispose de plusieurs structures conditionnelles différentes, mais nous allons nous concentrer sur les
        plus courantes.</p>
    <h4 id="ifelse">if...else</h4>
    <p>La structure conditionnelle <code>if...else</code> est utilisée pour exécuter un bloc de code si une condition
        est vraie et un autre bloc de code si la condition est fausse. Voici un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">2</span>) {
    alert(<span class="hljs-string">"a est supérieur à 2"</span>);
    } <span class="hljs-keyword">else</span> {
    alert(<span class="hljs-string">"a est inférieur à 2"</span>);
    }
    </div></code></pre>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté si la condition
        <code>a &gt; 2</code> est vraie. Sinon, le bloc de code entre les accolades <code>{ ... }</code> est exécuté.
    </p>
    <h4 id="ifelse-ifelse">if...else if...else</h4>
    <p>La structure conditionnelle <code>if...else if...else</code> est utilisée pour exécuter un bloc de code si une
        condition est vraie, un autre bloc de code si une autre condition est vraie, et un autre bloc de code si aucune
        des conditions n'est vraie. Voici un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">2</span>) {
    alert(<span class="hljs-string">"a est supérieur à 2"</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">2</span>) {
    alert(<span class="hljs-string">"a est inférieur à 2"</span>);
    } <span class="hljs-keyword">else</span> {
    alert(<span class="hljs-string">"a est égal à 2"</span>); <span class="hljs-comment">// affiche a est égal à 2</span>
    }
    </div></code></pre>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté si la condition
        <code>a &gt; 2</code> est vraie. Sinon, si la condition <code>a &lt; 2</code> est vraie, le bloc de code entre
        les accolades <code>{ ... }</code> est exécuté. Sinon, le bloc de code entre les accolades <code>{ ... }</code>
        est exécuté.
    </p>
    <h4 id="switchcase">switch...case</h4>
    <p>La structure conditionnelle <code>switch...case</code> est utilisée pour exécuter un bloc de code en fonction de
        plusieurs conditions. Voici un exemple :</p>
    <p>La structure <code>switch...case</code> en JavaScript (et dans de nombreux autres langages de programmation) est
        une manière de gérer plusieurs conditions. Elle est similaire à une série d'instructions
        {<code>if...else if...else</code>}, mais peut offrir une syntaxe plus propre et concise dans certains scénarios.
    </p>
    <p>Voici comment cela fonctionne :</p>
    <ol>
        <li>
            <p><strong>Syntaxe basique :</strong></p>
            <pre class="hljs"><code><div><span class="hljs-keyword">switch</span>(expression) {
        <span class="hljs-keyword">case</span> valeur1:
            <span class="hljs-comment">// code à exécuter si expression est égale à valeur1</span>
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> valeur2:
            <span class="hljs-comment">// code à exécuter si expression est égale à valeur2</span>
            <span class="hljs-keyword">break</span>;
        ...
        default:
        <span class="hljs-comment">// code à exécuter si aucune des valeurs ne correspond</span>
    }
    </div></code></pre>
            <p>Définition des lignes :</p>
            <ul>
                <li><strong>expression :</strong> Une expression dont la valeur est comparée à chaque case.</li>
                <li><strong>case valeur :</strong> Une valeur à comparer à l'expression.</li>
                <li><strong>break :</strong> Arrête l'exécution du bloc de code.</li>
                <li><strong>default :</strong> Spécifie le code à exécuter si aucune des valeurs ne correspond.</li>
            </ul>
        </li>
        <li>
            <p><strong>Avantages :</strong></p>
            <ul>
                <li>
                    <p><strong>Lisibilité :</strong> Pour les scénarios avec de nombreuses conditions basées sur une
                        seule valeur ou expression, <code>switch...case</code> peut être plus lisible que plusieurs
                        instructions <code>if...else if</code>.</p>
                </li>
                <li>
                    <p><strong>Performance :</strong> Dans certains environnements, l'utilisation d'un switch peut être
                        légèrement plus rapide que l'utilisation d'une série d'instructions <code>if...else if</code>,
                        car la valeur ou l'expression n'est évaluée qu'une seule fois.</p>
                </li>
            </ul>
        </li>
        <li>
            <p><strong>Limitations :</strong></p>
        </li>
    </ol>
    <ul>
        <li>
            <p><strong>Égalité stricte :</strong> <code>switch...cas</code>e utilise une égalité stricte
                (<code>===</code>) pour les comparaisons, ce qui signifie qu'il vérifie à la fois le type et la valeur.
            </p>
            <ul>
                <li>
                    <p><strong>Valeurs uniques :</strong> Chaque case doit avoir une valeur unique. Vous ne pouvez pas
                        gérer plusieurs valeurs avec un seul case sans utiliser des astuces, comme omettre le break pour
                        exécuter le même code pour plusieurs cases consécutifs.</p>
                </li>
                <li>
                    <p><strong>Moins flexible :</strong> <code>switch...case</code> est moins flexible que
                        <code>if...else</code> pour gérer des conditions complexes, car il est principalement conçu pour
                        comparer une seule expression ou valeur à plusieurs valeurs possibles.
                    </p>
                </li>
            </ul>
        </li>
    </ul>
    <p>Supposons que nous voulions écrire un code pour déterminer le jour de la semaine en fonction d'un numéro :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> dayNumber = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">switch</span>(dayNumber) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            alert(<span class="hljs-string">"Dimanche"</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            alert(<span class="hljs-string">"Lundi"</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            alert(<span class="hljs-string">"Mardi"</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            alert(<span class="hljs-string">"Mercredi"</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
            alert(<span class="hljs-string">"Jeudi"</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
            alert(<span class="hljs-string">"Vendredi"</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
            alert(<span class="hljs-string">"Samedi"</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            alert(<span class="hljs-string">"Valeur non valide"</span>);
    }
    Le code ci-dessus affichera <span class="hljs-string">"Dimanche"</span> dans la <span class="hljs-built_in">console</span>, car la valeur de la variable dayNumber est <span class="hljs-number">0.</span>
    </div></code></pre>
    <p>En conclusion, switch...case est un outil utile pour gérer plusieurs conditions basées sur une seule valeur ou
        expression. Cependant, il convient de bien comprendre ses avantages et limitations pour l'utiliser de manière
        appropriée.</p>
    <h3 id="boucles">Boucles</h3>
    <p>Les boucles permettent d'exécuter une portion de code plusieurs fois, ce qui est fondamental dans la
        programmation pour éviter la redondance et traiter des collections de données. JavaScript offre plusieurs types
        de boucles pour traiter différentes situations.</p>
    <h4 id="la-boucle-for">La boucle for</h4>
    <p>La boucle <code>for</code> est utilisée pour exécuter un bloc de code un nombre spécifié de fois. Voici un
        exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
    alert(i); <span class="hljs-comment">// Affichera 0, 1, 2, 3 et 4</span>
    }
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>let i = 0 :</strong> Déclare une variable i et l'initialise à 0.</li>
        <li><strong>i &lt; 5 :</strong> Vérifie si i est inférieur à 5.</li>
        <li><strong>i++ :</strong> Incrémente i de 1.</li>
        <li><strong>alert(i) :</strong> Affiche i dans la console.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté tant que la
        condition <code>i &lt; 5</code> est vraie. À chaque itération, la variable <code>i</code> est incrémentée de 1.
    </p>
    <h4 id="la-boucle-forin">La boucle for...in</h4>
    <p>La boucle <code>for...in</code> est utilisée pour exécuter un bloc de code pour chaque propriété d'un objet.
        Voici un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// Déclare un objet person</span>
    <span class="hljs-keyword">let</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> person) {
    alert(key); <span class="hljs-comment">// Affichera name et age</span>
    }
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>let key in person :</strong> Déclare une variable key et l'initialise à la première propriété de
            l'objet person.</li>
        <li><strong>alert(key) :</strong> Affiche key dans la console.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté pour chaque
        propriété de l'objet <code>person</code>. À chaque itération, la variable <code>key</code> contient le nom de la
        propriété.</p>
    <h4 id="la-boucle-forof">La boucle for...of</h4>
    <p>La boucle <code>for...of</code> est utilisée pour exécuter un bloc de code pour chaque élément d'un objet
        itérable. Voici un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// Déclare un tableau fruits</span>
    <span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fruit <span class="hljs-keyword">of</span> fruits) {
    alert(fruit); <span class="hljs-comment">// Affichera Apple, Banana et Orange</span>
    }
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>let fruit of fruits :</strong> Déclare une variable fruit et l'initialise au premier élément du
            tableau fruits.</li>
        <li><strong>alert(fruit) :</strong> Affiche fruit dans la console.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté pour chaque
        élément du tableau <code>fruits</code>. À chaque itération, la variable <code>fruit</code> contient la valeur de
        l'élément.</p>
    <h4 id="la-boucle-while">La boucle while</h4>
    <p>La boucle <code>while</code> est utilisée pour exécuter un bloc de code tant qu'une condition est vraie. Voici un
        exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// Déclare une variable i et l'initialise à 0</span>
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Exécute le bloc de code tant que i est inférieur à 5</span>
    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) {
    alert(i); <span class="hljs-comment">// Affichera 0, 1, 2, 3 et 4</span>
    i++;
    }
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>let i = 0 :</strong> Déclare une variable i et l'initialise à 0.</li>
        <li><strong>i &lt; 5 :</strong> Vérifie si i est inférieur à 5.</li>
        <li><strong>alert(i) :</strong> Affiche i dans la console.</li>
        <li><strong>i++ :</strong> Incrémente i de 1.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté tant que la
        condition <code>i &lt; 5</code> est vraie. À chaque itération, la variable <code>i</code> est incrémentée de 1.
    </p>
    <h4 id="la-boucle-dowhile">La boucle do...while</h4>
    <p>La boucle <code>do...while</code> est utilisée pour exécuter un bloc de code tant qu'une condition est vraie.
        Voici un exemple :</p>
    <p>Similaire à la boucle while, mais le code s'exécute au moins une fois, même si la condition n'est pas satisfaite
        dès le début.</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// Déclare une variable i et l'initialise à 0</span>
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Exécute le bloc de code</span>
    <span class="hljs-keyword">do</span> {
    alert(i); <span class="hljs-comment">// Affichera 0, 1, 2, 3 et 4</span>
    i++;
    } <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>);
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>let i = 0 :</strong> Déclare une variable i et l'initialise à 0.</li>
        <li><strong>let i = 1 :</strong> Déclare une variable i et</li>
        <li><strong>alert(i) :</strong> Affiche i dans la console.</li>
        <li><strong>i++ :</strong> Incrémente i de 1.</li>
        <li><strong>i &lt; 5 :</strong> Vérifie si i est inférieur à 5.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté tant que la
        condition <code>i &lt; 5</code> est vraie. À chaque itération, la variable <code>i</code> est incrémentée de 1.
    </p>
    <h4 id="la-boucle-foreach">La boucle forEach</h4>
    <p>La boucle <code>forEach</code> est utilisée pour exécuter un bloc de code pour chaque élément d'un tableau. Voici
        un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// Déclare un tableau fruits</span>
    <span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>];

    fruits.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fruit</span>) </span>{
    alert(fruit); <span class="hljs-comment">// Affichera Apple, Banana et Orange</span>
    });
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li>
            <p><strong>let fruits = ['Apple', 'Banana', 'Orange'] :</strong> Déclare un tableau fruits.</p>
        </li>
        <li>
            <p><strong>fruits.forEach(function(fruit) { ... }) :</strong> Exécute le bloc de code pour chaque élément du
                tableau fruits.</p>
        </li>
        <li>
            <p><strong>function(fruit) { ... } :</strong> Déclare une fonction anonyme avec un paramètre fruit.</p>
            <ul>
                <li>Une <code>fonction anonyme</code> est une fonction sans nom. En JavaScript, les fonctions anonymes
                    sont couramment utilisées dans des situations où une fonction est nécessaire pour un usage unique et
                    n'a pas besoin d'être réutilisée ailleurs.</li>
            </ul>
            <p>Caractéristiques d'une fonction anonyme :</p>
        </li>
        <li>
            <p><strong>Sans nom</strong> : Comme son nom l'indique, une fonction anonyme n'a pas de nom spécifié.</p>
        </li>
        <li>
            <p><strong>Utilisation courante avec des callbacks. :</strong> Les fonctions anonymes sont fréquemment
                utilisées comme fonctions de rappel (callbacks) pour des fonctions qui prennent d'autres fonctions en
                tant que paramètres, comme dans les événements ou les méthodes de tableau comme <code>.map()</code>,
                <code>.filter()</code> et <code>.forEach()</code>.
            </p>
        </li>
        <li>
            <p><strong>Autonomes ou assignées à une variable :</strong> Elles peuvent être auto-exécutées ou assignées à
                une variable.</p>
        </li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté pour chaque
        élément du tableau <code>fruits</code>. À chaque itération, la variable <code>fruit</code> contient la valeur de
        l'élément.</p>
    <h4 id="la-boucle-forawaitof">La boucle for...await...of</h4>
    <p>La boucle <code>for...await...of</code> est utilisée pour exécuter un bloc de code pour chaque élément d'un objet
        itérable, en attendant que la promesse soit résolue. Voici un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// Déclare un tableau fruits</span>
    <span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>];

    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncForEach</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> fruit <span class="hljs-keyword">of</span> array) {
        alert(fruit); <span class="hljs-comment">// Affichera Apple, Banana et Orange</span>
    }
    }

    asyncForEach(fruits);
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>let fruits = ['Apple', 'Banana', 'Orange'] :</strong> Déclare un tableau fruits.</li>
        <li><strong>async function asyncForEach(array) { ... } :</strong> Déclare une fonction asynchrone nommée
            asyncForEach avec un paramètre array.</li>
        <li><strong>for await (let fruit of array) { ... } :</strong> Exécute le bloc de code pour chaque élément du
            tableau fruits, en attendant que la promesse soit résolue.</li>
        <li>alert(fruit) : Affiche fruit dans la console.</li>
        <li><strong>asyncForEach(fruits) :</strong> Appelle la fonction asyncForEach avec le tableau fruits comme
            argument.</li>
    </ul>
    <p>Une fonction asynchrone est une fonction qui peut être interrompue et reprise plus tard. Elle est utilisée pour
        gérer les opérations asynchrones, comme les appels de fichiers, les appels de base de données, les appels de
        services Web, etc.</p>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté pour chaque
        élément du tableau <code>fruits</code>, en attendant que la promesse soit résolue. À chaque itération, la
        variable <code>fruit</code> contient la valeur de l'élément.</p>
    <p>Il est crucial de gérer correctement les conditions et les mises à jour dans les boucles pour éviter les boucles
        infinies, qui peuvent bloquer ou ralentir considérablement un programme ou une application web.</p>
    <p>En conclusion, les boucles en JavaScript offrent une flexibilité pour gérer différentes situations d'itération,
        rendant le traitement des collections de données efficace et simplifié.</p>
    <h3 id="fonctions-en-javascript">Fonctions en JavaScript</h3>
    <p>Les fonctions sont un pilier fondamental de JavaScript, un langage fortement axé sur les fonctions. Une fonction
        est un ensemble de déclarations qui effectue une tâche ou calcule une valeur. Grâce aux fonctions, les
        développeurs peuvent regrouper du code pour effectuer des tâches spécifiques, le rendre réutilisable et
        organiser leur code de manière plus structurée.</p>
    <h4 id="d%C3%A9claration-de-fonction">Déclaration de fonction</h4>
    <p>Une fonction est déclarée en utilisant le mot-clé <code>function</code>, suivi d'un nom de fonction, d'une liste
        de paramètres entre parenthèses <code>()</code>, et d'un bloc de code entre accolades <code>{ ... }</code>.
        Voici un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maFonction</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// Déclare une fonction nommée maFonction</span>
    <span class="hljs-comment">// Code à exécuter</span>
    }

    #### Fonctions nommées

    Les fonctions nommées sont utilisées pour exécuter des blocs de code réutilisables. Voici un exemple :

    <span class="hljs-string">``</span><span class="hljs-string">`js
    function sayHello() { // Déclare une fonction nommée sayHello
    alert("Hello"); // Affichera Hello
    }

    sayHello(); // Affichera Hello
    </span></div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>function sayHello() { ... } :</strong> Déclare une fonction nommée sayHello.</li>
        <li><strong>alert(&quot;Hello&quot;) :</strong> Affiche Hello dans la console.</li>
        <li><strong>sayHello() :</strong> Appelle la fonction sayHello.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté lorsque la
        fonction <code>sayHello</code> est appelée.</p>
    <h4 id="fonctions-anonymes">Fonctions anonymes</h4>
    <p>Une <code>fonction anonyme</code> est une fonction sans nom. En JavaScript, les fonctions anonymes sont
        couramment utilisées dans des situations où une fonction est nécessaire pour un usage unique et n'a pas besoin
        d'être réutilisée ailleurs.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Déclare une fonction anonyme et l'assigne à la variable sayHello</span>
    alert(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// Affichera Hello</span>
    };

    sayHello(); <span class="hljs-comment">// Affichera Hello</span>
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>let sayHello = function() { ... } :</strong> Déclare une fonction anonyme et l'assigne à la variable
            sayHello.</li>
        <li><strong>alert(&quot;Hello&quot;) :</strong> Affiche Hello dans la console.</li>
        <li><strong>sayHello() :</strong> Appelle la fonction sayHello.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté lorsque la
        fonction <code>sayHello</code> est appelée.</p>
    <h4 id="fonctions-fl%C3%A9ch%C3%A9es-es6">Fonctions fléchées (ES6)</h4>
    <p>Introduites avec ES6, elles offrent une syntaxe plus concise pour définir les fonctions, en particulier pour les
        fonctions qui n'ont qu'une seule expression.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> sayHello = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Déclare une fonction fléchée et l'assigne à la variable sayHello</span>
    alert(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// Affichera Hello</span>
    };

    sayHello(); <span class="hljs-comment">// Affichera Hello</span>

    <span class="hljs-comment">//----------------------------------------------------------</span>

    <span class="hljs-keyword">const</span> additionner = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;

    <span class="hljs-built_in">console</span>.log(additionner(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Affiche 5</span>
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>let sayHello = () =&gt; { ... } :</strong> Déclare une fonction fléchée et l'assigne à la variable
            sayHello.</li>
        <li><strong>alert(&quot;Hello&quot;) :</strong> Affiche Hello dans la console.</li>
        <li><strong>sayHello() :</strong> Appelle la fonction sayHello.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté lorsque la
        fonction <code>sayHello</code> est appelée.</p>
    <h4 id="fonctions-auto-ex%C3%A9cut%C3%A9es-iife---immediately-invoked-function-expression">Fonctions auto-exécutées
        (IIFE - Immediately Invoked Function Expression)</h4>
    <p>En JavaScript, une IIFE, ou &quot;Immediately Invoked Function Expression&quot;, est une fonction qui s'exécute
        immédiatement après avoir été définie. C'est une manière courante d'encapsuler la logique pour éviter les
        conflits de portée et pour empêcher l'exposition involontaire de variables à la portée globale.</p>
    <p>Syntaxe de base:</p>
    <pre class="hljs"><code><div>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Corps de la fonction</span>
    })();
    </div></code></pre>
    <p>Le but principal des IIFE est de créer une nouvelle portée lexicale. Ainsi, toutes les variables déclarées dans
        la IIFE ne peuvent pas être accessibles à l'extérieur de la fonction.</p>
    <pre class="hljs"><code><div>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> variableLocale = <span class="hljs-string">"Je suis une variable locale à l'IIFE"</span>;
    <span class="hljs-built_in">console</span>.log(variableLocale);
    })();

    <span class="hljs-comment">// console.log(variableLocale); // Cela provoquera une erreur car 'variableLocale' n'est pas définie en dehors de l'IIFE.</span>
    </div></code></pre>
    <p><strong>Avantages des IIFE :</strong></p>
    <ul>
        <li>
            <p><strong>Eviter de polluer la portée globale</strong>: En encapsulant le code dans une IIFE, on prévient
                l'ajout involontaire de variables à la portée globale, ce qui peut conduire à des conflits et des
                comportements inattendus.</p>
        </li>
        <li>
            <p><strong>Organisation du code :</strong> Les IIFE peuvent être utilisées pour regrouper des
                fonctionnalités spécifiques ou des unités logiques de code, rendant le code plus organisé et lisible.
            </p>
        </li>
        <li>
            <p><strong>Variables privées :</strong> Les IIFE peuvent être utilisées pour simuler des variables privées,
                car tout ce qui est défini à l'intérieur de l'IIFE n'est pas accessible en dehors.</p>
        </li>
        <li>
            <p><strong>Usage avec d'autres structures :</strong> Les IIFE sont souvent utilisées en combinaison avec
                d'autres structures, comme les objets et les fonctions, pour créer des modules, des espaces de noms, et
                d'autres motifs avancés de programmation.</p>
        </li>
    </ul>
    <p>Variantes et usages:</p>
    <p>Les IIFE peuvent également accepter des paramètres:</p>
    <p>Syntaxe de base:</p>
    <pre class="hljs"><code><div>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param1, param2</span>) </span>{
    <span class="hljs-comment">// Corps de la fonction</span>
    })(valeur1, valeur2);
    </div></code></pre>
    <pre class="hljs"><code><div>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
    <span class="hljs-built_in">console</span>.log(message);
    })(<span class="hljs-string">"Salut, ceci est un message dans une IIFE !"</span>);
    </div></code></pre>
    <p>IIFE avec une syntaxe de fonction fléchée (bien que moins courante) :</p>
    <p>Syntaxe de base:</p>
    <pre class="hljs"><code><div>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Corps de la fonction</span>
    })();
    </div></code></pre>
    <pre class="hljs"><code><div>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Salut, ceci est un message dans une IIFE !"</span>);
    })();
    </div></code></pre>
    <p>En conclusion, les IIFE sont un outil puissant en JavaScript pour encapsuler le code, prévenir les conflits
        potentiels et créer des structures plus complexes tout en gardant le code propre et bien organisé.</p>
    <h4 id="contructeurs-de-fonction">Contructeurs de fonction</h4>
    <p>Les constructeurs de fonction sont utilisés pour créer des objets. Voici un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée Person</span>
    <span class="hljs-keyword">this</span>.name = name; <span class="hljs-comment">// Déclare une propriété name</span>
    <span class="hljs-keyword">this</span>.age = age; <span class="hljs-comment">// Déclare une propriété age</span>
    }

    <span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"John"</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// Crée un nouvel objet person</span>
    onsole.log(person.name); <span class="hljs-comment">// Affichera John</span>
    <span class="hljs-built_in">console</span>.log(person.age); <span class="hljs-comment">// Affichera 30</span>
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>function Person(name, age) { ... } :</strong> Déclare une fonction nommée Person avec deux
            paramètres name et age.</li>
        <li><strong>this.name = name :</strong> Déclare une propriété name et l'assigne à la valeur du paramètre name.
        </li>
        <li><strong>this.age = age :</strong> Déclare une propriété age et l'assigne à la valeur du paramètre age.</li>
        <li><strong>let person = new Person('John', 30) :</strong> Crée un nouvel objet person en appelant la fonction
            Person avec les arguments 'John' et 30.</li>
        <li><strong>console.log(person.name) :</strong> Affiche la valeur de la propriété name de l'objet person.</li>
        <li><strong>console.log(person.age) :</strong> Affiche la valeur de la propriété age de l'objet person.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, le bloc de code entre les accolades <code>{ ... }</code> est exécuté lorsque la
        fonction <code>Person</code> est appelée avec l'opérateur <code>new</code>.</p>
    <h4 id="fonctions-r%C3%A9cursives">Fonctions récursives</h4>
    <p>Une fonction récursive est une fonction qui s'appelle elle-même, directement ou indirectement, dans le but de
        résoudre un problème en le divisant en sous-problèmes plus petits et plus gérables. La récursion est un concept
        fondamental en informatique et peut être utilisée pour résoudre une variété de problèmes de manière élégante.
        Exemple classique: Factorielle</p>
    <p>La factorielle d'un nombre nn, notée n!n!, est le produit de tous les entiers positifs de 1 à nn. La factorielle
        peut être définie de manière récursive comme suit:</p>
    <p><strong>n! = n * (n-1)!</strong></p>
    <p>En JavaScript, cela pourrait être représenté comme :</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorielle</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// Vérifie si n est égal à 0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// Cas de base</span>
    }
    <span class="hljs-keyword">return</span> n * factorielle(n - <span class="hljs-number">1</span>); <span class="hljs-comment">// Appel récursif</span>
    }

    <span class="hljs-built_in">console</span>.log(factorielle(<span class="hljs-number">5</span>)); <span class="hljs-comment">// Affiche 120</span>
    </div></code></pre>
    <p>Concepts clés:</p>
    <ul>
        <li>
            <p><strong>Cas de base :</strong> Chaque fonction récursive doit avoir un ou plusieurs cas de base qui
                déterminent quand la fonction doit cesser de s'appeler elle-même. Sans cela, la fonction s'appellera
                indéfiniment, conduisant à une débordement de pile (stack overflow).</p>
        </li>
        <li>
            <p><strong>Cas récursif :</strong> C'est là que la fonction s'appelle elle-même, généralement avec un
                argument modifié ou réduit d'une certaine manière.</p>
        </li>
        <li>
            <p><strong>Diviser pour régner :</strong> Beaucoup d'algorithmes récursifs adoptent l'approche &quot;diviser
                pour régner&quot;, où le problème est divisé en sous-problèmes plus petits jusqu'à ce qu'il atteigne le
                cas de base.</p>
        </li>
    </ul>
    <p>Autres exemples:</p>
    <ul>
        <li><strong>Suite de Fibonacci :</strong> La suite de Fibonacci est une séquence où chaque nombre est la somme
            des deux précédents.</li>
    </ul>
    <p>Exemple de code:</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-comment">// Vérifie si n est inférieur ou égal à 1</span>
        <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// Cas de base</span>
    }
    <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>); <span class="hljs-comment">// Appel récursif</span>
    }

    <span class="hljs-built_in">console</span>.log(fibonacci(<span class="hljs-number">5</span>)); <span class="hljs-comment">// Affiche 5</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDown</span>(<span class="hljs-params">number</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée countDown avec un paramètre number</span>
    <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// Vérifie si number est inférieur à 0</span>
        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Retourne undefined</span>
    }

    <span class="hljs-built_in">console</span>.log(number); <span class="hljs-comment">// Affiche number dans la console</span>

    countDown(number - <span class="hljs-number">1</span>); <span class="hljs-comment">// Appelle la fonction countDown avec number - 1 comme argument</span>
    }

    countDown(<span class="hljs-number">5</span>); <span class="hljs-comment">// Affichera 5, 4, 3, 2, 1 et 0</span>
    </div></code></pre>
    <p>Exerciece à faire :
        Créez une fonction récursive qui calcule la somme des nombres de 0 à n.</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// Vérifie si n est égal à 0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Cas de base</span>
    }
    <span class="hljs-keyword">return</span> n + sum(n - <span class="hljs-number">1</span>); <span class="hljs-comment">// Appel récursif</span>
    }

    <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">5</span>)); <span class="hljs-comment">// Affiche 15 (5 + 4 + 3 + 2 + 1)</span>
    </div></code></pre>
    <p>La fonction commence par vérifier le cas de base: si <code>n</code> est égal à <code>0</code>, elle renvoie
        simplement <code>0</code>. Sinon, elle s'appelle elle-même avec <code>n−1n−1</code> et ajoute <code>n</code> au
        résultat.</p>
    <h4 id="fonctions-de-rappel-callbacks">Fonctions de rappel (callbacks)</h4>
    <p>Une fonction de rappel est une fonction qui est passée à une autre fonction en tant qu'argument et qui est
        exécutée à l'intérieur de la fonction appelée. Les fonctions de rappel sont couramment utilisées avec des
        fonctions asynchrones, mais ne sont pas limitées à l'asynchronisme.</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée sayHello</span>
    alert(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// Affichera Hello</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executeCallback</span>(<span class="hljs-params">callback</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée executeCallback avec un paramètre callback</span>
    callback(); <span class="hljs-comment">// Appelle la fonction callback</span>
    }

    executeCallback(sayHello); <span class="hljs-comment">// Affichera Hello</span>
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>function sayHello() { ... } :</strong> Déclare une fonction nommée sayHello.</li>
        <li><strong>function executeCallback(callback) { ... } :</strong> Déclare une fonction nommée executeCallback
            avec un paramètre callback.</li>
        <li><strong>callback() :</strong> Appelle la fonction callback.</li>
        <li><strong>executeCallback(sayHello) :</strong> Appelle la fonction executeCallback avec la fonction sayHello
            comme argument.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, la fonction <code>sayHello</code> est passée à la fonction <code>executeCallback</code>
        en tant qu'argument et est appelée à l'intérieur de la fonction <code>executeCallback</code>.</p>
    <h4 id="fonctions-de-rappel-asynchrones">Fonctions de rappel asynchrones</h4>
    <p>Les fonctions de rappel asynchrones sont des fonctions de rappel qui sont exécutées de manière asynchrone,
        c'est-à-dire qu'elles sont exécutées après que le reste du code a été exécuté. Les fonctions de rappel
        asynchrones sont couramment utilisées avec des fonctions asynchrones, comme les appels de fichiers, les appels
        de base de données, les appels de services Web, etc.</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée sayHello</span>
    alert(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// Affichera Hello</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executeCallback</span>(<span class="hljs-params">callback</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée executeCallback avec un paramètre callback</span>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// Déclare une fonction anonyme</span>
        callback(); <span class="hljs-comment">// Appelle la fonction callback</span>
    }, <span class="hljs-number">1000</span>); <span class="hljs-comment">// Attend 1000 millisecondes (1 seconde)</span>
    }

    executeCallback(sayHello); <span class="hljs-comment">// Affichera Hello après 1 seconde</span>
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>function sayHello() { ... } :</strong> Déclare une fonction nommée sayHello.</li>
        <li><strong>function executeCallback(callback) { ... } :</strong> Déclare une fonction nommée executeCallback
            avec un paramètre callback.</li>
        <li><strong>setTimeout(function() { ... }, 1000) :</strong> Exécute la fonction anonyme après 1000 millisecondes
            (1 seconde).</li>
        <li><strong>callback() :</strong> Appelle la fonction callback.</li>
        <li><strong>executeCallback(sayHello) :</strong> Appelle la fonction executeCallback avec la fonction sayHello
            comme argument.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, la fonction <code>sayHello</code> est passée à la fonction <code>executeCallback</code>
        en tant qu'argument et est appelée à l'intérieur de la fonction <code>executeCallback</code> après 1 seconde.
    </p>
    <h4 id="fonctions-de-rappel-avec-param%C3%A8tres">Fonctions de rappel avec paramètres</h4>
    <p>Les fonctions de rappel avec paramètres sont des fonctions de rappel qui acceptent des paramètres. Voici un
        exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée sayHello avec un paramètre name</span>
    alert(<span class="hljs-string">"Hello "</span> + name); <span class="hljs-comment">// Affichera Hello suivi du paramètre name</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executeCallback</span>(<span class="hljs-params">callback</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée executeCallback avec un paramètre callback</span>
    callback(<span class="hljs-string">"John"</span>); <span class="hljs-comment">// Appelle la fonction callback avec le paramètre John</span>
    }

    executeCallback(sayHello); <span class="hljs-comment">// Affichera Hello John</span>
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>function sayHello(name) { ... } :</strong> Déclare une fonction nommée sayHello avec un paramètre
            name.</li>
        <li><strong>function executeCallback(callback) { ... } :</strong> Déclare une fonction nommée executeCallback
            avec un paramètre callback.</li>
        <li><strong>callback(&quot;John&quot;) :</strong> Appelle la fonction callback avec le paramètre John.</li>
        <li><strong>executeCallback(sayHello) :</strong> Appelle la fonction executeCallback avec la fonction sayHello
            comme argument.</li>
        <li><strong>alert(&quot;Hello &quot; + name) :</strong> Affiche Hello suivi du paramètre name.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, la fonction <code>sayHello</code> est passée à la fonction <code>executeCallback</code>
        en tant qu'argument et est appelée à l'intérieur de la fonction <code>executeCallback</code> avec le paramètre
        <code>John</code>.
    </p>
    <h4 id="fonctions-de-rappel-avec-plusieurs-param%C3%A8tres">Fonctions de rappel avec plusieurs paramètres</h4>
    <p>Les fonctions de rappel avec plusieurs paramètres sont des fonctions de rappel qui acceptent plusieurs
        paramètres. Voici un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">name, age</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée sayHello avec deux paramètres name et age</span>
    alert(<span class="hljs-string">"Hello "</span> + name + <span class="hljs-string">", you are "</span> + age + <span class="hljs-string">" years old"</span>); <span class="hljs-comment">// Affichera Hello suivi du paramètre name et du paramètre age</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executeCallback</span>(<span class="hljs-params">callback</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée executeCallback avec un paramètre callback</span>
    callback(<span class="hljs-string">"John"</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// Appelle la fonction callback avec le paramètre John et le paramètre 30</span>
    }

    executeCallback(sayHello); <span class="hljs-comment">// Affichera Hello John, you are 30 years old</span>
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>function sayHello(name, age) { ... } :</strong> Déclare une fonction nommée sayHello avec deux
            paramètres name et age.</li>
        <li><strong>function executeCallback(callback) { ... } :</strong> Déclare une fonction nommée executeCallback
            avec un paramètre callback.</li>
        <li><strong>callback(&quot;John&quot;, 30) :</strong> Appelle la fonction callback avec le paramètre John et le
            paramètre 30.</li>
        <li><strong>executeCallback(sayHello) :</strong> Appelle la fonction executeCallback avec la fonction sayHello
            comme argument.</li>
        <li><strong>alert(&quot;Hello &quot; + name + &quot;, you are &quot; + age + &quot; years old&quot;) :</strong>
            Affiche Hello suivi du paramètre name et du paramètre age.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, la fonction <code>sayHello</code> est passée à la fonction <code>executeCallback</code>
        en tant qu'argument et est appelée à l'intérieur de la fonction <code>executeCallback</code> avec le paramètre
        <code>John</code> et le paramètre <code>30</code>.
    </p>
    <h4 id="fonctions-de-rappel-avec-une-valeur-de-retour">Fonctions de rappel avec une valeur de retour</h4>
    <p>Les fonctions de rappel avec une valeur de retour sont des fonctions de rappel qui retournent une valeur. Voici
        un exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée add avec deux paramètres a et b</span>
    <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">// Retourne la somme de a et b</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executeCallback</span>(<span class="hljs-params">callback</span>) </span>{
    <span class="hljs-comment">// Déclare une fonction nommée executeCallback avec un paramètre callback</span>
    <span class="hljs-keyword">return</span> callback(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// Retourne la valeur de la fonction callback avec le paramètre 1 et le paramètre 2</span>
    }

    <span class="hljs-keyword">let</span> result = executeCallback(add); <span class="hljs-comment">// Appelle la fonction executeCallback avec la fonction add comme argument et assigne le résultat à la variable result</span>
    <span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// Affichera 3</span>
    </div></code></pre>
    <p>Explication :</p>
    <ul>
        <li><strong>function add(a, b) { ... } :</strong> Déclare une fonction nommée add avec deux paramètres a et b.
        </li>
        <li><strong>function executeCallback(callback) { ... } :</strong> Déclare une fonction nommée executeCallback
            avec un paramètre callback.</li>
        <li><strong>return a + b :</strong> la somme de a et b.</li>
        <li><strong>return callback(1, 2) :</strong> Retourne la valeur de la fonction callback avec le paramètre 1 et
            le paramètre 2.</li>
        <li><strong>let result = executeCallback(add) :</strong> Appelle la fonction executeCallback avec la fonction
            add comme argument et assigne le résultat à la variable result.</li>
        <li><strong>console.log(result) :</strong> Affiche la valeur de la variable result.</li>
    </ul>
    <p>Dans l'exemple ci-dessus, la fonction <code>add</code> est passée à la fonction <code>executeCallback</code> en
        tant qu'argument et est appelée à l'intérieur de la fonction <code>executeCallback</code> avec le paramètre
        <code>1</code> et le paramètre <code>2</code>. La valeur de retour de la fonction <code>add</code> est ensuite
        retournée par la fonction <code>executeCallback</code> et assignée à la variable <code>result</code>.
    </p>
    <h3 id="port%C3%A9e-des-variables">Portée des variables</h3>
    <p>La portée d'une variable en programmation détermine où une variable peut être accédée dans le code. En
        JavaScript, la portée des variables est essentiellement déterminée par leur emplacement et la manière dont elles
        sont déclarées.</p>
    <ol>
        <li>**Portée Globale :
            Toute variable déclarée en dehors d'une fonction possède une portée globale. Cela signifie qu'elle peut être
            accessible et modifiée depuis n'importe quel autre code du script, y compris les fonctions.</li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> variableGlobale = <span class="hljs-string">"Je suis une variable globale"</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">afficherVariable</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(variableGlobale);
    }

    afficherVariable(); <span class="hljs-comment">// Affiche "Je suis une variable globale"</span>
    </div></code></pre>
    <ol start="2">
        <li><strong>Portée locale (ou de fonction):</strong></li>
    </ol>
    <p>Les variables déclarées à l'intérieur d'une fonction ont une portée locale. Elles ne sont accessibles qu'à
        l'intérieur de cette fonction.</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">afficherMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> variableLocale = <span class="hljs-string">"Je suis une variable locale"</span>;
    <span class="hljs-built_in">console</span>.log(variableLocale);
    }

    afficherMessage(); <span class="hljs-comment">// Affiche "Je suis une variable locale"</span>
    <span class="hljs-comment">// console.log(variableLocale);  // Erreur : variableLocale n'est pas définie</span>
    </div></code></pre>
    <ol start="3">
        <li>Portée de bloc (avec let et const):</li>
    </ol>
    <p>Avec l'introduction de let et const dans ES6 (ECMAScript 2015), JavaScript dispose désormais de variables à
        portée de bloc. Cela signifie que ces variables sont limitées à la portée du bloc (délimité par des accolades {
        }), de la boucle ou de l'expression dans laquelle elles sont définies.Exemple : Déclarer des fonctions en ligne
        lors de leur utilisation. ```
        declareThis = function() {};</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">let</span> variableDeBloc = <span class="hljs-string">"Je suis limitée à ce bloc"</span>;
    <span class="hljs-built_in">console</span>.log(variableDeBloc); <span class="hljs-comment">// "Je suis limitée à ce bloc"</span>
    }
    <span class="hljs-comment">// console.log(variableDeBloc);  // Erreur : variableDeBloc n'est pas définie</span>
    </div></code></pre>
    <ol start="4">
        <li>Variables <code>var</code> :</li>
    </ol>
    <p>Avant ES6, JavaScript n'avait que des variables <code>var</code>, qui sont soit globales, soit limitées à la
        portée d'une fonction, indépendamment de la portée de bloc.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    <span class="hljs-built_in">console</span>.log(i);
    }
    <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// Affiche "3", car i est accessible en dehors de la boucle</span>
    </div></code></pre>
    <p>Il est généralement recommandé d'utiliser let ou const pour une meilleure gestion de la portée et éviter les
        erreurs potentielles liées à la portée des variables.</p>
    <p>Conclusion:</p>
    <p>Comprendre la portée des variables est crucial en JavaScript pour éviter des bugs inattendus et écrire du code
        propre et maintenable. C'est aussi une base pour comprendre des concepts plus avancés comme les fermetures
        (closures).</p>
    <h3 id="fermetures-closures">Fermetures (Closures)</h3>
    <p>En JavaScript, une fermeture (ou closure en anglais) est une fonction qui a accès à la portée parente, même après
        que la fonction parente ait terminé son exécution. Cela peut sembler complexe de prime abord, mais en comprenant
        comment fonctionnent les portées en JavaScript, les closures deviennent plus intuitifs.</p>
    <ol>
        <li><strong>Comprendre les Closures :</strong></li>
    </ol>
    <p>Une fermeture se crée chaque fois qu'une fonction est définie à l'intérieur d'une autre fonction.</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fonctionExterne</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fonctionInterne</span>(<span class="hljs-params">y</span>) </span>{
        <span class="hljs-keyword">return</span> x + y;
    }
    <span class="hljs-keyword">return</span> fonctionInterne;
    }

    <span class="hljs-keyword">let</span> exemple = fonctionExterne(<span class="hljs-number">10</span>);
    <span class="hljs-built_in">console</span>.log(exemple(<span class="hljs-number">5</span>)); <span class="hljs-comment">// Affiche 15</span>
    </div></code></pre>
    <p>Dans l'exemple ci-dessus, fonctionInterne est une fermeture qui a accès à la variable x, qui est une variable de
        sa portée externe (fonctionExterne). 2. Pourquoi sont-elles utiles ?</p>
    <p>Les closures sont utiles pour :</p>
    <ul>
        <li>Créer des fonctions d'usine.</li>
        <li>Émuler la &quot;privacité&quot; dans les objets (données privées).</li>
        <li>Utiliser dans les fonctions comme les <em>callbacks</em>, où vous voulez conserver un état spécifique.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creerCompteur</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> compteur = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> compteur++;
    };
    }

    <span class="hljs-keyword">let</span> monCompteur = creerCompteur();
    <span class="hljs-built_in">console</span>.log(monCompteur()); <span class="hljs-comment">// 0</span>
    <span class="hljs-built_in">console</span>.log(monCompteur()); <span class="hljs-comment">// 1</span>
    <span class="hljs-built_in">console</span>.log(monCompteur()); <span class="hljs-comment">// 2</span>
    </div></code></pre>
    <p>Dans cet exemple, chaque fois que creerCompteur est appelée, elle crée une nouvelle closure autour de la variable
        compteur. Ainsi, chaque compteur peut maintenir son propre état.</p>
    <ol start="4">
        <li><strong>Précautions :</strong></li>
    </ol>
    <p>Bien que les closures soient puissants, ils peuvent également causer des problèmes si vous ne faites pas
        attention. Un problème courant est la boucle &quot;for&quot; avec des closures. Si vous ne comprenez pas bien
        comment fonctionnent les closures, vous pourriez vous retrouver à créer des boucles qui ne se comportent pas
        comme prévu.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(i);
    }, <span class="hljs-number">1000</span>);
    }

    <span class="hljs-comment">// Affiche "3" trois fois au lieu de 0, 1, 2</span>
    </div></code></pre>
    <p>Pour résoudre ce problème, vous pouvez utiliser une <code>IIFE</code> (Immediately Invoked Function Expression)
        ou simplement utiliser <a href="">let</a> à la place de <code>var</code>.</p>
    <p>Conclusion:</p>
    <p>Les closures sont l'un des concepts fondamentaux et puissants de JavaScript. Bien qu'ils puissent sembler
        déroutants au début, avec la pratique, ils deviennent un outil essentiel dans la boîte à outils de tout
        développeur JavaScript.</p>
    <h2 id="callbacks-et-promesses">Callbacks et promesses</h2>
    <p>En JavaScript, de nombreuses opérations sont asynchrones, comme les requêtes réseau, les lectures de fichiers ou
        les timeouts. Les callbacks et les promesses sont deux approches pour gérer l'asynchronisme.</p>
    <h3 id="callbacks">Callbacks</h3>
    <p>Un callback est simplement une fonction passée en tant qu'argument à une autre fonction, qui est ensuite exécutée
        après que cette dernière a terminé son exécution.</p>
    <ol>
        <li><strong>Utilisation de Callbacks :</strong></li>
    </ol>
    <p>Voici un exemple simple d'un callback utilisé avec la fonction <code>setTimeout</code> :</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">monCallback</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Callback exécuté après 2 secondes"</span>);
    }

    setTimeout(monCallback, <span class="hljs-number">2000</span>);
    </div></code></pre>
    <ol start="2">
        <li><strong>Callbacks et Asynchronisme :</strong></li>
    </ol>
    <p>Les callbacks sont souvent utilisés pour traiter des opérations asynchrones :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>); <span class="hljs-comment">// Requiert le module 'fs' pour la lecture de fichiers en Node.js</span>

    fs.readFile(<span class="hljs-string">"monFichier.txt"</span>, <span class="hljs-string">"utf8"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
    <span class="hljs-built_in">console</span>.log(data);
    });
    </div></code></pre>
    <p>Ce phénomène est souvent appelé &quot;Callback Hell&quot; ou &quot;Pyramide de la Doom&quot;. Cela rend le code
        difficile à lire et à maintenir.</p>
    <h2 id="promesses">Promesses</h2>
    <p>Les promesses sont une alternative aux callbacks pour gérer l'asynchronisme. Une promesse représente une valeur
        qui pourrait être disponible maintenant, dans le futur, ou jamais.</p>
    <ol>
        <li><strong>Création d'une promesse :</strong></li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> maPromesse = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        resolve(<span class="hljs-string">"Promesse résolue après 2 secondes"</span>);
    }, <span class="hljs-number">2000</span>);
    });

    maPromesse.then(<span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message);
    });
    </div></code></pre>
    <ol start="2">
        <li><strong>Chaînage des Promesses :</strong></li>
    </ol>
    <p>Les promesses peuvent être chaînées pour éviter le &quot;Callback Hell&quot; :</p>
    <pre class="hljs"><code><div>operation1()
    .then(<span class="hljs-function">(<span class="hljs-params">result1</span>) =&gt;</span> operation2(result1))
    .then(<span class="hljs-function">(<span class="hljs-params">result2</span>) =&gt;</span> operation3(result2))
    .then(<span class="hljs-function">(<span class="hljs-params">result3</span>) =&gt;</span> {
        <span class="hljs-comment">// Traitement final</span>
    })
    .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-comment">// Gestion des erreurs</span>
    });
    </div></code></pre>
    <ol start="3">
        <li><strong>async/await :</strong></li>
    </ol>
    <p>Introduit avec ES2017, <code>async/await</code> est une syntaxe qui permet d'écrire des opérations asynchrones de
        manière plus lisible, comme si elles étaient synchrones :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traitementAsynchrone</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">let</span> result1 = <span class="hljs-keyword">await</span> operation1();
        <span class="hljs-keyword">let</span> result2 = <span class="hljs-keyword">await</span> operation2(result1);
        <span class="hljs-keyword">let</span> result3 = <span class="hljs-keyword">await</span> operation3(result2);
        <span class="hljs-comment">// Traitement final</span>
    } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-comment">// Gestion des erreurs</span>
    }
    }

    traitementAsynchrone();
    </div></code></pre>
    <p>Tandis que les callbacks ont été la méthode principale pour gérer l'asynchronisme en JavaScript pendant des
        années, les promesses et <code>async/await</code> offrent une syntaxe plus claire et plus facile à gérer pour
        les opérations asynchrones complexes. Il est donc recommandé de privilégier ces dernières dans les applications
        modernes.</p>
    <h2 id="programmation-orient%C3%A9e-objet-poo">Programmation Orientée Objet (POO)</h2>
    <p>La programmation orientée objet (POO) est un paradigme de programmation qui repose sur l'idée de structurer le
        code en unités appelées &quot;objets&quot;. Ces objets regroupent à la fois des données (souvent appelées
        &quot;attributs&quot; ou &quot;propriétés&quot;) et des fonctions (appelées &quot;méthodes&quot;) qui opèrent
        sur ces données. En JavaScript, la POO est supportée et offre des mécanismes tels que les prototypes, et plus
        récemment, les classes.</p>
    <h3 id="objets-et-propri%C3%A9t%C3%A9s">Objets et propriétés</h3>
    <p>En JavaScript, un objet est une collection non ordonnée de propriétés. Chaque propriété est une association entre
        une clé (ou un nom de propriété) et une valeur. Une valeur de propriété peut être une fonction, qui est alors
        appelée une méthode de l'objet. Les objets en JavaScript sont extrêmement flexibles et sont la base de
        nombreuses fonctionnalités du langage.</p>
    <ol>
        <li><strong>Création d'objets</strong></li>
    </ol>
    <p>Il existe plusieurs manières de créer des objets en JavaScript :</p>
    <p><strong>Littéral d'objet :</strong></p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> voiture = {
    <span class="hljs-attr">marque</span>: <span class="hljs-string">"Toyota"</span>,
    <span class="hljs-attr">modele</span>: <span class="hljs-string">"Corolla"</span>,
    <span class="hljs-attr">annee</span>: <span class="hljs-number">2020</span>,
    <span class="hljs-attr">demarrer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"La voiture démarre !"</span>);
    },
    };
    </div></code></pre>
    <p><strong>Constructeur d'objet</strong></p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> voiture = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
    voiture.marque = <span class="hljs-string">"Toyota"</span>;
    voiture.modele = <span class="hljs-string">"Corolla"</span>;
    voiture.annee = <span class="hljs-number">2020</span>;
    voiture.demarrer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"La voiture démarre !"</span>);
    };
    </div></code></pre>
    <ol start="3">
        <li><strong>Accéder aux propriétés</strong></li>
    </ol>
    <p>On peut accéder aux propriétés d'un objet de deux manières :</p>
    <ul>
        <li>Notation point :</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-built_in">console</span>.log(voiture.marque); <span class="hljs-comment">// Affiche "Toyota"</span>
    </div></code></pre>
    <ul>
        <li>Notation crochets:</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-built_in">console</span>.log(voiture[<span class="hljs-string">"marque"</span>]); <span class="hljs-comment">// Affiche "Toyota"</span>
    </div></code></pre>
    <p>La notation crochets est particulièrement utile lorsque le nom de la propriété est stocké dans une variable ou
        lorsqu'il contient des caractères spéciaux.</p>
    <ol start="3">
        <li><strong>Ajout et suppression de propriétés</strong></li>
    </ol>
    <p>JavaScript permet d'ajouter ou de supprimer des propriétés d'un objet après sa création.</p>
    <ul>
        <li>Ajout :</li>
    </ul>
    <pre class="hljs"><code><div>voiture.couleur = <span class="hljs-string">"rouge"</span>;
    </div></code></pre>
    <ul>
        <li>Suppresion :</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">delete</span> voiture.annee;
    </div></code></pre>
    <ol start="4">
        <li><strong>Vérification de l'existence d'une propriété</strong></li>
    </ol>
    <p>Pour vérifier si un objet possède une propriété, on peut utiliser l'opérateur <code>in</code> :</p>
    <pre class="hljs"><code><div><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"marque"</span> <span class="hljs-keyword">in</span> voiture); <span class="hljs-comment">// Affiche "true"</span>
    </div></code></pre>
    <ol start="5">
        <li><strong>Méthodes</strong></li>
    </ol>
    <p>Les méthodes sont des fonctions associées à un objet. Elles peuvent accéder et opérer sur les données contenues
        dans l'objet.</p>
    <pre class="hljs"><code><div>voiture.demarrer(); <span class="hljs-comment">// Affiche "La voiture démarre !"</span>
    </div></code></pre>
    <p>Les objets sont au cœur de JavaScript et sont utilisés pour représenter des <code>choses</code> avec un ensemble
        de propriétés. La capacité à créer, modifier et accéder à ces propriétés rend JavaScript extrêmement puissant et
        flexible.</p>
    <h3 id="constructeurs-et-prototypes">Constructeurs et prototypes</h3>
    <p>Le système d'objet en JavaScript est basé sur des prototypes plutôt que sur des classes, comme c'est le cas dans
        de nombreux autres langages de programmation orientée objet. Cependant, JavaScript offre une notion de
        constructeurs qui, combinée à des prototypes, permet de réaliser des modèles de programmation similaires à ceux
        basés sur des classes.</p>
    <ol>
        <li><strong>Constructeurs</strong></li>
    </ol>
    <p>Un constructeur est une fonction qui est utilisée avec le mot-clé new pour créer et initialiser un nouvel objet.
    </p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Voiture</span>(<span class="hljs-params">marque, modele, annee</span>) </span>{
    <span class="hljs-keyword">this</span>.marque = marque;
    <span class="hljs-keyword">this</span>.modele = modele;
    <span class="hljs-keyword">this</span>.annee = annee;
    <span class="hljs-keyword">this</span>.demarrer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.marque + <span class="hljs-string">" démarre !"</span>);
    };
    }

    <span class="hljs-keyword">let</span> maVoiture = <span class="hljs-keyword">new</span> Voiture(<span class="hljs-string">"Toyota"</span>, <span class="hljs-string">"Corolla"</span>, <span class="hljs-number">2020</span>);
    maVoiture.demarrer(); <span class="hljs-comment">// Affiche "Toyota démarre !"</span>
    </div></code></pre>
    <ol start="2">
        <li><strong>Prototypes</strong></li>
    </ol>
    <p>Chaque objet en JavaScript possède une propriété interne appelée prototype. C'est une référence à un autre objet.
        Lorsque vous tentez d'accéder à une propriété qui n'existe pas dans un objet, JavaScript tente de la trouver
        dans son prototype.</p>
    <p>L'utilisation du prototype est surtout utile pour ajouter des méthodes et des propriétés communes à toutes les
        instances d'un objet, sans les définir individuellement pour chaque instance.</p>
    <pre class="hljs"><code><div>Voiture.prototype.klaxonner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Beep Beep !"</span>);
    };

    maVoiture.klaxonner(); <span class="hljs-comment">// Affiche "Beep Beep !"</span>
    </div></code></pre>
    <p>Grâce à ce mécanisme, tous les objets créés à partir du constructeur Voiture auront maintenant accès à la méthode
        klaxonner.</p>
    <ol start="3">
        <li><strong>Héritage de prototype</strong></li>
    </ol>
    <p>L'héritage en JavaScript est réalisé par la délégation de prototype. Si un objet ne possède pas une propriété,
        JavaScript recherche cette propriété dans le prototype de l'objet, puis dans le prototype du prototype, et ainsi
        de suite, jusqu'à ce qu'il atteigne le haut de la chaîne de prototype.</p>
    <p>Pour réaliser un héritage entre deux fonctions constructeurs :</p>
    <pre class="hljs"><code><div>function Vehicule() {
        this.estUnVehicule = true;
    }

    Voiture.prototype = new Vehicule();

    let monVehicule = new Voiture(&quot;Honda&quot;, &quot;Civic&quot;, 2021);
    console.log(monVehicule.estUnVehicule);  // Affiche &quot;true&quot;
    </div></code></pre>
    <p>Les constructeurs et prototypes sont des éléments fondamentaux de la programmation orientée objet en JavaScript.
        Ils permettent de définir des &quot;classes&quot; et des méthodes, d'instancier de nouveaux objets, et
        d'implémenter des mécanismes d'héritage. Même si cela peut sembler complexe au premier abord, cette flexibilité
        permet une grande variété de modèles de programmation en JavaScript.</p>
    <h3 id="h%C3%A9ritage-et-polymorphisme">Héritage et polymorphisme</h3>
    <p>En programmation orientée objet, l'héritage est un mécanisme qui permet à une classe d'acquérir les propriétés et
        les comportements d'une autre classe. Le polymorphisme, quant à lui, permet à des objets de différentes classes
        d'être traités comme s'ils appartenaient à la même classe, généralement via l'héritage.</p>
    <p>JavaScript, n'étant pas basé sur des classes mais sur des prototypes, offre un système d'héritage et de
        polymorphisme un peu différent des langages traditionnels comme Java ou C++. Cependant, avec l'introduction des
        classes ES6, JavaScript fournit désormais des mécanismes d'héritage plus traditionnels.</p>
    <ol>
        <li><strong>Héritage</strong></li>
    </ol>
    <p>Avec les classes ES6, JavaScript introduit le mot-clé extends pour mettre en œuvre l'héritage.</p>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicule</span> </span>{
    <span class="hljs-keyword">constructor</span>(type) {
        <span class="hljs-keyword">this</span>.type = type;
    }

    description() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Un véhicule de type <span class="hljs-subst">${<span class="hljs-keyword">this</span>.type}</span>`</span>;
    }
    }

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Voiture</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vehicule</span> </span>{
    <span class="hljs-keyword">constructor</span>(marque, modele) {
        <span class="hljs-keyword">super</span>(<span class="hljs-string">"voiture"</span>); <span class="hljs-comment">// Appel du constructeur parent</span>
        <span class="hljs-keyword">this</span>.marque = marque;
        <span class="hljs-keyword">this</span>.modele = modele;
    }

    description() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">super</span>.description()}</span> de marque <span class="hljs-subst">${<span class="hljs-keyword">this</span>.marque}</span> et de modèle <span class="hljs-subst">${
        <span class="hljs-keyword">this</span>.modele
        }</span>`</span>;
    }
    }

    <span class="hljs-keyword">let</span> maVoiture = <span class="hljs-keyword">new</span> Voiture(<span class="hljs-string">"Toyota"</span>, <span class="hljs-string">"Corolla"</span>);
    <span class="hljs-built_in">console</span>.log(maVoiture.description()); <span class="hljs-comment">// "Un véhicule de type voiture de marque Toyota et de modèle Corolla"</span>
    </div></code></pre>
    <ol start="2">
        <li><strong>Polymorphisme</strong></li>
    </ol>
    <p>Le polymorphisme permet aux objets de différentes classes d'être traités comme s'ils étaient de la même classe.
        C'est souvent réalisé par l'intermédiaire de l'héritage.</p>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Moto</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vehicule</span> </span>{
    <span class="hljs-keyword">constructor</span>(marque) {
        <span class="hljs-keyword">super</span>(<span class="hljs-string">"moto"</span>);
        <span class="hljs-keyword">this</span>.marque = marque;
    }

    description() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">super</span>.description()}</span> de marque <span class="hljs-subst">${<span class="hljs-keyword">this</span>.marque}</span>`</span>;
    }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">afficherDescription</span>(<span class="hljs-params">vehicule</span>) </span>{
    <span class="hljs-built_in">console</span>.log(vehicule.description());
    }

    <span class="hljs-keyword">let</span> maMoto = <span class="hljs-keyword">new</span> Moto(<span class="hljs-string">"Harley Davidson"</span>);
    afficherDescription(maVoiture); <span class="hljs-comment">// "Un véhicule de type voiture de marque Toyota et de modèle Corolla"</span>
    afficherDescription(maMoto); <span class="hljs-comment">// "Un véhicule de type moto de marque Harley Davidson"</span>
    </div></code></pre>
    <p>Même si <code>maVoiture</code> et <code>maMoto</code> sont de classes différentes, elles peuvent être traitées de
        la même manière grâce au polymorphisme.</p>
    <p>L'héritage et le polymorphisme sont des concepts essentiels de la programmation orientée objet. Ils offrent une
        structure et une flexibilité pour concevoir des systèmes plus modulaires et réutilisables. Avec l'introduction
        des classes en ES6, JavaScript peut désormais exploiter ces concepts d'une manière similaire aux langages
        orientés objet traditionnels, tout en conservant sa flexibilité inhérente basée sur les prototypes.</p>
    <h3 id="es6-classes">ES6 Classes</h3>
    <p>Avec l'introduction de <code>ES6</code> (ou ES2015), JavaScript a introduit le concept de classes. Avant cette
        version, la programmation orientée objet en JavaScript était basée sur des fonctions et des prototypes. Les
        classes ES6 offrent une syntaxe plus propre et plus concise pour créer des objets et gérer l'héritage.</p>
    <p><strong><code>ES6</code></strong> est l'abréviation de &quot;ECMAScript 6&quot;, et il est également connu sous
        le nom d'ECMAScript 2015. Pour comprendre ce que signifie <code>ES6</code>, il est essentiel de connaître la
        signification d'ECMAScript :</p>
    <p>ECMAScript est une norme pour les langages de script, dont JavaScript est l'implémentation la plus connue. La
        norme est définie par un groupe appelé ECMA International, et le nom &quot;ECMAScript&quot; est dérivé de cette
        organisation.</p>
    <p>Historiquement, différentes versions d'ECMAScript ont été publiées au fil des années :</p>
    <p>ES6 (ECMAScript 2015)</p>
    <p>ES6 est l'abréviation de <code>ECMAScript 6</code>, et il est également connu sous le nom d'ECMAScript 2015. Pour
        comprendre ce que signifie ES6, il est essentiel de connaître la signification d'ECMAScript :</p>
    <p>ECMAScript est une norme pour les langages de script, dont JavaScript est l'implémentation la plus connue. La
        norme est définie par un groupe appelé ECMA International, et le nom &quot;ECMAScript&quot; est dérivé de cette
        organisation.</p>
    <p>Historiquement, différentes versions d'ECMAScript ont été publiées au fil des années :</p>
    <ul>
        <li>ES1 (ECMAScript 1) - 1997</li>
        <li>ES2 (ECMAScript 2) - 1998</li>
        <li>ES3 (ECMAScript 3) - 1999</li>
        <li>ES4 (ECMAScript 4) - Ce projet a été abandonné.</li>
        <li>ES5 (ECMAScript 5) - 2009</li>
        <li>ES6 (ECMAScript 2015 ou ECMAScript 6) - 2015</li>
    </ul>
    <p>La sixième édition, ES6 (ou ECMAScript 2015), est particulièrement notable car elle a introduit un grand nombre
        de nouvelles fonctionnalités et de changements significatifs dans le langage. Parmi ces ajouts figurent :</p>
    <ul>
        <li>Classes</li>
        <li>Modules</li>
        <li>Flèches fonctions (=&gt;)</li>
        <li>Promesses</li>
        <li>Opérateur de propagation (...)</li>
        <li>Nouvelles méthodes pour les objets et les tableaux</li>
        <li>Mots-clés <code>let</code> et <code>const</code> pour la déclaration de variables</li>
        <li>Et bien plus encore.</li>
    </ul>
    <p>Après <code>ES6</code>, l'ECMA International a adopté une approche annuelle pour la publication des
        spécifications, utilisant désormais le format &quot;ECMAScript [année]&quot;, par exemple, ECMAScript 2016,
        ECMAScript 2017, etc. Ces versions sont parfois désignées par leur numéro de version (comme ES7, ES8), mais le
        nom officiel est basé sur l'année de publication.</p>
    <ol>
        <li><strong>Définition d'une classe</strong></li>
    </ol>
    <p>Une <code>class</code> est un concept fondamental en programmation orientée objet (POO). Elle sert de modèle ou
        de plan pour créer des objets (instances de la classe). La classe encapsule les données pour l'objet et les
        méthodes pour manipuler ces données.</p>
    <p>Pour définir une nouvelle classe on utilise le mot-clé <code>class</code></p>
    <pre class="hljs"><code><div>class Personne {
        constructor(nom, prenom) {
            this.nom = nom;
            this.prenom = prenom;
        }

        saluer() {
            console.log(`Bonjour, je m'appelle ${this.prenom} ${this.nom}!`);
        }
    }
    </div></code></pre>
    <ol start="2">
        <li><strong>Instanciation</strong></li>
    </ol>
    <p>Dans la programmation orientée objet (POO), <code>instancier</code> est le processus de création d'un objet à
        partir d'une classe. L'objet ainsi créé est appelé une &quot;instance&quot; de cette classe.</p>
    <p>Chaque instance d'une classe possède des propriétés (ou attributs) et des méthodes définies par cette classe,
        mais l'état (les valeurs des attributs) peut varier entre les différentes instances.
        Comment instancier une classe ?</p>
    <p>En JavaScript, en utilisant la syntaxe <code>ES6</code> pour les classes, vous instanciez une classe en utilisant
        le mot-clé <code>new</code> suivi du nom de la classe et de parenthèses (qui peuvent contenir des arguments si
        le constructeur de la classe en requiert).</p>
    <p>Pour créer une nouvelle instance d'une classe on utilise le mot-clé <code>new</code>.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> personne1 = <span class="hljs-keyword">new</span> Personne(<span class="hljs-string">"Doe"</span>, <span class="hljs-string">"John"</span>);
    personne1.saluer(); <span class="hljs-comment">// "Bonjour, je m'appelle John Doe!"</span>
    </div></code></pre>
    <p>Dans ce code ci-dessus, le mot-clé <code>this</code> fait référence à l'objet en cours d'instanciation (dans ce
        contexte, une instance de Personne).</p>
    <p>En résumé, la classe Personne sert de modèle pour créer des objets qui représentent des personnes avec un nom et
        un prénom. Elle fournit également une méthode pour ces objets afin de les saluer en utilisant leurs noms et
        prénoms.</p>
    <ol start="3">
        <li><strong>Héritage</strong></li>
    </ol>
    <p>Pour hériter d'une classe on utilise le mot-clé <code>extends</code></p>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Etudiant</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Personne</span> </span>{
    <span class="hljs-keyword">constructor</span>(nom, prenom, matricule) {
        <span class="hljs-keyword">super</span>(nom, prenom); <span class="hljs-comment">// Appel du constructeur parent</span>
        <span class="hljs-keyword">this</span>.matricule = matricule;
    }

    sePresenter() {
        <span class="hljs-keyword">super</span>.saluer();
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Mon numéro de matricule est <span class="hljs-subst">${<span class="hljs-keyword">this</span>.matricule}</span>.`</span>);
    }
    }

    <span class="hljs-keyword">let</span> etudiant1 = <span class="hljs-keyword">new</span> Etudiant(<span class="hljs-string">"Smith"</span>, <span class="hljs-string">"Jane"</span>, <span class="hljs-string">"12345"</span>);
    etudiant1.sePresenter();
    <span class="hljs-comment">// "Bonjour, je m'appelle Jane Smith!"</span>
    <span class="hljs-comment">// "Mon numéro de matricule est 12345."</span>
    </div></code></pre>
    <ol start="4">
        <li><strong>Méthodes statiques</strong></li>
    </ol>
    <p>Les méthodes statiques sont attachées à la classe elle-même et non à ses instances.</p>
    <pre class="hljs"><code><div>class Utilitaires {
        static pi() {
            return 3.141592653589793;
        }
    }

    console.log(Utilitaires.pi());  // 3.141592653589793
    </div></code></pre>
    <ol start="5">
        <li><strong>Getters et setters</strong></li>
    </ol>
    <p>Utilisez les mots-clés <code>get</code> et <code>set</code> pour créer des accesseurs et des mutateurs.</p>
    <pre class="hljs"><code><div>class Cercle {
        constructor(rayon) {
            this._rayon = rayon;
        }

        get rayon() {
            return this._rayon;
        }

        set rayon(valeur) {
            if (valeur &lt; 0) {
                console.log(&quot;Le rayon ne peut pas être négatif!&quot;);
                return;
            }
            this._rayon = valeur;
        }

        get aire() {
            return Utilitaires.pi() * this._rayon * this._rayon;
        }
    }

    let cercle1 = new Cercle(5);
    console.log(cercle1.aire);  // 78.53981633974483
    cercle1.rayon = -10;        // &quot;Le rayon ne peut pas être négatif!&quot;
    </div></code></pre>
    <p>Les classes ES6 ont rendu la programmation orientée objet en JavaScript plus accessible et plus proche de ce que
        la plupart des programmeurs connaissent des autres langages. Toutefois, il est essentiel de comprendre que sous
        le capot, JavaScript utilise toujours son mécanisme de prototype pour gérer les classes et l'héritage.</p>
    <h3 id="encapsulation-et-abstraction">Encapsulation et abstraction</h3>
    <p>L'encapsulation et l'abstraction sont deux des quatre piliers fondamentaux de la programmation orientée objet
        (les deux autres étant l'héritage et le polymorphisme). Ces concepts sont essentiels pour concevoir des
        logiciels modulaires, maintenables et sécurisés.</p>
    <p><strong>Encapsulation</strong></p>
    <p>L'encapsulation est le regroupement des données (propriétés) et des méthodes (fonctions) qui agissent sur ces
        données en une seule unité, ou objet. Elle permet également de restreindre l'accès direct à certaines propriétés
        ou méthodes, garantissant ainsi l'intégrité des données.</p>
    <p><strong>Caractéristiques de l'encapsulation:</strong></p>
    <ol>
        <li><strong>Modificateurs d'accès:</strong> Les classes peuvent utiliser des modificateurs d'accès comme
            private, protected ou public pour déterminer la visibilité des propriétés et des méthodes. (Note: JavaScript
            n'a introduit la notion de champs privés qu'avec ES2020.)</li>
    </ol>
    <p><strong>private :</strong> est utilisée pour restreindre l'accès à certaines propriétés ou méthodes d'une classe.
        Lorsqu'un élément est marqué comme private, il ne peut être accédé ou modifié qu'à partir de l'intérieur de
        cette classe, et non depuis un objet instancié ou toute autre classe.</p>
    <p>En JavaScript, avant ES2020, il n'y avait pas de vraie notion de membres privés nativement supportée. Cependant,
        il était courant d'utiliser des conventions, comme préfixer les propriétés avec un underscore (<code>_</code>),
        pour indiquer qu'elles sont destinées à être traitées comme privées. Mais cette convention n'empêche pas
        réellement l'accès à ces propriétés depuis l'extérieur de la classe.</p>
    <p>Avec l'ajout des champs de classe privés dans ES2020, JavaScript introduit une véritable notion de propriétés
        privées. Ces champs sont déclarés en préfixant le nom du champ avec un <code>#</code>.</p>
    <p>Exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compteur</span> </span>{
    #valeur;

    <span class="hljs-keyword">constructor</span>(valeurInitiale = 0) {
        <span class="hljs-keyword">this</span>.#valeur = valeurInitiale;
    }

    incrementer() {
        <span class="hljs-keyword">this</span>.#valeur++;
    }

    obtenirValeur() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#valeur;
    }
    }

    <span class="hljs-keyword">const</span> compteur = <span class="hljs-keyword">new</span> Compteur();
    compteur.incrementer();
    <span class="hljs-built_in">console</span>.log(compteur.obtenirValeur()); <span class="hljs-comment">// Affiche 1</span>
    <span class="hljs-built_in">console</span>.log(compteur.#valeur); <span class="hljs-comment">// Erreur: La propriété privée #valeur doit être déclarée dans une classe contenant son accès</span>
    </div></code></pre>
    <p><strong>protected
            :</strong><code> Le modificateur d'accès</code>protected<code>(protected en anglais) est un peu plus restrictif. Lorsqu'un membre est marqué comme</code>protected`,
        il peut être accédé à l'intérieur de la classe qui le contient et également à l'intérieur des classes qui en
        héritent (sous-classes). Il n'est pas accessible de l'extérieur de ces classes.</p>
    <p>JavaScript n'a pas de véritable notion native de membres protected, mais il est courant d'utiliser des
        conventions, comme préfixer les propriétés avec un underscore (<code>_</code>), pour indiquer qu'elles sont
        destinées à être traitées comme protégées.
        Exemple (en utilisant la convention <code>_</code> pour protected en JavaScript):</p>
    <p>Voici quelques façons d'émuler protected en JavaScript :</p>
    <ul>
        <li><strong><em>Conventions :</em></strong> Similaire à l'approche de l'underscore pour les membres
            &quot;privés&quot;, vous pouvez préfixer les propriétés et méthodes &quot;protégées&quot; avec un
            underscore. Cela n'empêche pas réellement l'accès à ces membres en dehors de la classe, mais cela signale
            aux développeurs qu'ils doivent être traités comme s'ils étaient protégés.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">this</span>._protectedProp = <span class="hljs-string">"Je suis protégé par convention"</span>;
    }
    }

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derivee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>{
    afficher() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>._protectedProp);
    }
    }

    <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> Derivee();
    obj.afficher(); <span class="hljs-comment">// Affiche "Je suis protégé par convention"</span>
    </div></code></pre>
    <ul>
        <li><strong><em>Symbols :</em></strong> Une autre approche consiste à utiliser des symbols comme clés pour les
            propriétés protégées. Les <code>symbols</code> sont uniques et ne peuvent pas être reproduits, donc sauf si
            le symbol est partagé ou accessible, les propriétés qu'il indexe peuvent être considérées comme protégées.
        </li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> protectedProp = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"protectedProp"</span>);

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">this</span>[protectedProp] = <span class="hljs-string">"Je suis protégé par un Symbol"</span>;
    }
    }

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derivee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>{
    afficher() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>[protectedProp]);
    }
    }

    <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> Derivee();
    obj.afficher(); <span class="hljs-comment">// Affiche "Je suis protégé par un Symbol"</span>
    </div></code></pre>
    <p><strong>public :</strong> indique qu'une propriété ou méthode peut être accessible depuis n'importe où, que ce
        soit à l'intérieur ou à l'extérieur de la classe où elle est définie. C'est le niveau d'accès le moins
        restrictif.</p>
    <p>En JavaScript, par défaut, toutes les propriétés et méthodes sont public à moins que vous ne preniez des mesures
        spécifiques pour limiter leur visibilité (par exemple, en utilisant des champs privés avec le préfixe #
        introduit dans ES2020).
        Exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Personne</span> </span>{
    <span class="hljs-keyword">constructor</span>(nom, age) {
        <span class="hljs-keyword">this</span>.nom = nom; <span class="hljs-comment">// Ceci est une propriété publique</span>
        <span class="hljs-keyword">this</span>.age = age; <span class="hljs-comment">// Ceci est aussi une propriété publique</span>
    }

    presenter() {
        <span class="hljs-comment">// Ceci est une méthode publique</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Je m'appelle <span class="hljs-subst">${<span class="hljs-keyword">this</span>.nom}</span> et j'ai <span class="hljs-subst">${<span class="hljs-keyword">this</span>.age}</span> ans.`</span>);
    }
    }

    <span class="hljs-keyword">const</span> paul = <span class="hljs-keyword">new</span> Personne(<span class="hljs-string">"Paul"</span>, <span class="hljs-number">30</span>);
    paul.presenter(); <span class="hljs-comment">// Affiche "Je m'appelle Paul et j'ai 30 ans."</span>
    <span class="hljs-built_in">console</span>.log(paul.nom); <span class="hljs-comment">// Affiche "Paul" car la propriété 'nom' est publique</span>
    </div></code></pre>
    <p>Dans cet exemple, les propriétés <code>nom</code> et <code>age</code> ainsi que la méthode presenter() sont
        toutes publiques. Vous pouvez y accéder et les manipuler depuis n'importe où.</p>
    <p>Il est à noter que dans la plupart des autres langages de programmation orientée objet (comme Java ou C++), vous
        devriez explicitement marquer une propriété ou méthode comme <code>public</code> pour qu'elle soit accessible de
        l'extérieur. Mais en JavaScript, c'est le comportement par défaut. Vous n'avez pas besoin d'utiliser le mot-clé
        <code>public</code> car il n'existe pas en tant que tel dans le langage.
    </p>
    <p>Malgré l'utilisation de conventions pour indiquer une propriété comme étant <code>protected</code>, rien
        n'empêche techniquement d'accéder à ces propriétés depuis l'extérieur en JavaScript. Ces conventions sont plus
        des directives pour les développeurs que des règles strictes imposées par le langage lui-même.</p>
    <p>Il f aut noter que ces techniques n'offrent qu'une protection nominale en JavaScript. Elles sont utiles pour
        indiquer l'intention, mais elles ne fournissent pas une encapsulation stricte comme le ferait un véritable
        modificateur protected dans d'autres langages.</p>
    <ol start="2">
        <li><strong>Getters et setters:</strong> Ils permettent d'encapsuler l'accès aux propriétés tout en offrant une
            interface pour les manipuler.</li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boite</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">this</span>._contenu = [];
    }

    <span class="hljs-keyword">get</span> contenu() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._contenu;
    }

    ajouter(element) {
        <span class="hljs-keyword">this</span>._contenu.push(element);
    }

    retirer() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._contenu.pop();
    }
    }
    </div></code></pre>
    <p><strong>Abstraction</strong></p>
    <p>L'abstraction est un processus de dissimulation des détails de mise en œuvre complexes et de présentation
        uniquement des fonctionnalités essentielles à l'utilisateur. Cela permet à l'utilisateur de se concentrer sur ce
        que fait l'objet plutôt que sur la manière dont il le fait.</p>
    <p>Caractéristiques de l'abstraction:</p>
    <ol>
        <li>
            <p><strong>Simplification:</strong> Présentation uniquement des informations nécessaires, ce qui simplifie
                la perception de l'utilisateur.</p>
        </li>
        <li>
            <p><strong>Réutilisabilité:</strong> En cachant les détails, les objets peuvent être réutilisés dans
                différents contextes sans nécessiter de modifications.</p>
        </li>
        <li>
            <p><strong>Sécurité:</strong> En cachant les détails de mise en œuvre, on peut empêcher les utilisateurs
                d'effectuer des actions non désirées ou potentiellement dangereuses.</p>
        </li>
    </ol>
    <pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Voiture</span> </span>{
    <span class="hljs-keyword">constructor</span>(marque, modele) {
        <span class="hljs-keyword">this</span>.marque = marque;
        <span class="hljs-keyword">this</span>.modele = modele;
        <span class="hljs-keyword">this</span>._kilometrage = <span class="hljs-number">0</span>;
    }

    avancer(distance) {
        <span class="hljs-keyword">this</span>._augmenterKilometrage(distance);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`La voiture avance de <span class="hljs-subst">${distance}</span> km.`</span>);
    }

    <span class="hljs-comment">// méthode privée (abstraite pour l'utilisateur)</span>
    _augmenterKilometrage(distance) {
        <span class="hljs-keyword">this</span>._kilometrage += distance;
    }
    }
    </div></code></pre>
    <p>Dans cet exemple, la méthode <code>_augmenterKilometrage</code> est un détail de mise en œuvre caché à
        l'utilisateur. L'utilisateur interagit simplement avec la voiture en utilisant la méthode <code>avancer</code>.
    </p>
    <p>L'encapsulation et l'abstraction sont des concepts clés pour garantir l'intégrité des données, simplifier
        l'interface utilisateur, et permettre la flexibilité et l'évolutivité du code. En appliquant correctement ces
        principes, les développeurs peuvent créer des systèmes modulaires et robustes.</p>
    <h2 id="manipulation-du-dom">Manipulation du DOM</h2>
    <p>La manipulation du Document Object Model (DOM) est l'une des tâches fondamentales lors de la programmation web
        côté client avec JavaScript. Le DOM est une représentation structurée d'un document web, et il fournit une
        interface qui permet de modifier sa structure, son style et son contenu.</p>
    <h3 id="s%C3%A9lection-d%C3%A9l%C3%A9ments">Sélection d'éléments</h3>
    <p>La sélection d'éléments est une étape essentielle lors de la manipulation du DOM en JavaScript. Elle nous permet
        d'accéder à des éléments spécifiques du document afin d'en lire ou modifier le contenu, les attributs, les
        classes et bien d'autres propriétés.</p>
    <h4 id="m%C3%A9thodes-de-s%C3%A9lection-d%C3%A9l%C3%A9ments">Méthodes de sélection d'éléments</h4>
    <p>Il existe plusieurs méthodes pour sélectionner des éléments dans le DOM :</p>
    <ul>
        <li><code>document.getElementById(id)</code> : Sélectionne un élément par son attribut id.</li>
        <li><code>document.querySelector(selecteur)</code> : Sélectionne le premier élément correspondant au sélecteur
            CSS spécifié.</li>
        <li><code>document.querySelectorAll(selecteur)</code> : Sélectionne tous les éléments correspondant au sélecteur
            CSS spécifié.</li>
        <li><code>document.getElementsByClassName(nomDeClasse)</code> : Sélectionne tous les éléments ayant la classe
            spécifiée.</li>
        <li><code>document.getElementsByTagName(nomDeBalise)</code> : Sélectionne tous les éléments ayant la balise
            spécifiée.</li>
        <li><code>document.getElementsByName(nom)</code> : Sélectionne tous les éléments ayant l'attribut name spécifié.
        </li>
        <li><code>document.forms[nomDuFormulaire]</code> : Sélectionne le formulaire ayant le nom spécifié.</li>
    </ul>
    <h4 id="s%C3%A9lection-d%C3%A9l%C3%A9ments-imbriqu%C3%A9s">Sélection d'éléments imbriqués</h4>
    <p>Il est possible de sélectionner des éléments imbriqués en utilisant la notation point ou la notation crochets :
    </p>
    <ul>
        <li><code>document.getElementById(id)</code> : Permet de sélectionner un élément unique en utilisant l'attribut
            <code>id</code> de cet élément. Retourne un élément ou <code>null</code> si aucun élément ne possède cet ID.
        </li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monId"</span>);
    </div></code></pre>
    <br>
    <ul>
        <li><code>document.querySelector(selecteur)</code> : Permet de sélectionner le premier élément qui correspond à
            un sélecteur CSS donné. Il offre une grande flexibilité, car il prend en charge tous les sélecteurs CSS.
        </li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> premierElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".maClasse"</span>); <span class="hljs-comment">// Sélectionne le premier élément ayant la classe "maClasse"</span>
    </div></code></pre>
    <br>
    <ul>
        <li><code>document.querySelectorAll(selecteur)</code> : Similaire à <code>querySelector</code>, mais sélectionne
            tous les éléments correspondant au sélecteur CSS fourni. Retourne un objet de type NodeList.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> tousLesElements = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"div .maClasse"</span>);
    </div></code></pre>
    <p><strong>Note sur NodeList et HTMLCollection</strong></p>
    <ul>
        <li><code>NodeList</code> et <code>HTMLCollection</code> ressemblent à des tableaux, mais ils ont des méthodes
            et propriétés différentes.</li>
        <li><code>querySelectorAll</code> retourne un <code>NodeList</code> qui est statique, c'est-à-dire qu'il ne se
            met pas à jour si le DOM change.</li>
        <li><code>getElementsByClassName</code> et <code>getElementsByTagNam</code>e retournent un HTMLCollection qui
            est &quot;vivant&quot;, c'est-à-dire qu'il se met à jour automatiquement lorsque le DOM est modifié.</li>
    </ul>
    <br>
    <ul>
        <li><code>document.getElementsByClassName(nomDeClasse)</code> : Sélectionne une liste d'éléments ayant une
            classe spécifique. Retourne un objet de type <code>HTMLCollection</code>.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> elements = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">"maClasse"</span>);
    </div></code></pre>
    <br>
    <ul>
        <li><code>document.getElementsByTagName(nomDeBalise)</code> : Sélectionne une liste d'éléments selon le nom du
            tag (par exemple, 'div', 'a', 'li'). Retourne un objet de type HTMLCollection.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> elements = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"div"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"li"</span>);
    </div></code></pre>
    <br>
    <ul>
        <li><code>document.getElementsByName(nom)</code> : Sélectionne tous les éléments ayant l'attribut name spécifié.
        </li>
    </ul>
    <p>La méthode <code>getElementsByName</code> est utilisée pour sélectionner des éléments en fonction de l'attribut
        <code>name</code>. Elle est fréquemment utilisée avec des formulaires pour sélectionner des éléments tels que
        les boutons radio, les cases à cocher et les champs de saisie, qui possèdent souvent un attribut name.
    </p>
    <p>La méthode document.getElementsByName retourne une collection d'éléments ayant un attribut name spécifique. La
        collection renvoyée est un objet NodeList &quot;vivant&quot;, ce qui signifie qu'il se met à jour
        automatiquement si le DOM est modifié.</p>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nom d'utilisateur"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"gender"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"male"</span> /&gt;</span> Homme
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"gender"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"female"</span> /&gt;</span> Femme
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> radioButtons = <span class="hljs-built_in">document</span>.getElementsByName(<span class="hljs-string">"gender"</span>); <span class="hljs-comment">// ['Homme', 'Femme']</span>

    <span class="hljs-comment">// On parcourt la collection et on affiche la valeur de l'élément sélectionné</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; radioButtons.length; i++) {
    <span class="hljs-keyword">if</span> (radioButtons[i].checked) {
        <span class="hljs-built_in">console</span>.log(radioButtons[i].value);
    }
    }
    </div></code></pre>
    <p>Résultat :</p>
    <form>
        <input type="text" name="username" placeholder="Nom d'utilisateur"> <br><br>
        <input type="radio" name="gender" value="male" checked> Homme
        <input type="radio" name="gender" value="female"> Femme
    </form>
    <br>
    <ul>
        <li>
            <p><code>document.forms[nomDuFormulaire]</code> :
                La propriété <code>document.forms</code> permet d'accéder à tous les éléments <code>&lt;form&gt;</code>
                d'un document. Vous pouvez utiliser cette propriété pour accéder directement à un formulaire en fonction
                de son attribut <code>name</code> ou de son <code>index</code>.</p>
            <p>L'objet document.forms est une collection de tous les éléments de formulaire (
            <form>) présents dans le document.</p>
        </li>
    </ul>
    <p>Code HTML :</p>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"inscriptionForm"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nom d'utilisateur"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Mot de passe"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>S'inscrire<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginForm"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nom d'utilisateur"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Mot de passe"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Se connecter<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
    </div></code></pre>
    <p>Pour accéder au formulaire d'inscription en utilisant son nom :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> formInscription = <span class="hljs-built_in">document</span>.forms[<span class="hljs-string">"inscriptionForm"</span>];
    </div></code></pre>
    <p>Pour accéder au deuxième formulaire (formulaire de connexion) en utilisant son index :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> formLogin = <span class="hljs-built_in">document</span>.forms[<span class="hljs-number">1</span>];
    </div></code></pre>
    <p>Une fois que vous avez une référence à un formulaire spécifique, vous pouvez accéder à ses éléments de la même
        manière, par exemple :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> username = formInscription.elements[<span class="hljs-string">"username"</span>];
    <span class="hljs-keyword">const</span> password = formInscription.elements[<span class="hljs-string">"password"</span>];
    </div></code></pre>
    <p>L'utilisation de <code>document.forms</code> offre une manière pratique et directe d'accéder aux éléments de
        formulaire sans avoir à utiliser d'autres sélecteurs du DOM. Il est particulièrement utile dans les scripts qui
        traitent la validation de formulaire, l'envoi de données, etc.</p>
    <p>Résultat :</p>
    <p>Formulaire d'insription</p>
    <form name="inscriptionForm">
        <input type="text" name="username" placeholder="Nom d'utilisateur"><br>
        <input type="password" name="password" placeholder="Mot de passe"><br>
        <button type="submit">S'inscrire</button>
    </form>
    <p>Formulaire de connexion</p>
    <form name="loginForm">
        <input type="text" name="username" placeholder="Nom d'utilisateur"><br>
        <input type="password" name="password" placeholder="Mot de passe"><br>
        <button type="submit">Se connecter</button>
    </form>
    <br>
    <h3 id="modification-du-contenu">Modification du contenu</h3>
    <p><code>.innerText et .textContent</code></p>
    <ul>
        <li>
            <p>Description: Ces propriétés permettent de récupérer ou de définir le contenu textuel d'un élément.</p>
        </li>
        <li>
            <p>Différence: Bien que similaires, <code>.textContent</code> récupère le contenu de tous les éléments, y
                compris les éléments
                <script></script> et <style></style>, tandis que <code>.innerText</code> est plus conscient du style et
                ne retourne que le texte visible à l'utilisateur.
            </p>
        </li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monElement"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monElement"</span>);
    element.innerText = <span class="hljs-string">"Nouveau texte"</span>;
    </div></code></pre>
    <p>Résultat :</p>
    <div id="monElement">
        Nouveau texte
    </div>
    <br>
    <p><code>.innerHTML</code></p>
    <ul>
        <li>Description: Cette propriété permet de récupérer ou de définir le contenu HTML d'un élément.</li>
    </ul>
    <p>Exemple:</p>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monElement"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monElement"</span>);
    element.innerHTML = <span class="hljs-string">"&lt;strong&gt;Nouveau&lt;/strong&gt; contenu HTML"</span>;
    </div></code></pre>
    <p><strong>NB:</strong> Lorsque vous utilisez <code>innerHTML</code> pour définir le contenu HTML d'un élément, le
        navigateur analyse le contenu et crée les nœuds DOM correspondants. Cela peut être une opération coûteuse,
        surtout si vous modifiez fréquemment le contenu d'un élément. Si vous ne modifiez que le texte d'un élément, il
        est préférable d'utiliser <code>innerText</code> ou <code>textContent</code> à la place.</p>
    <p><strong>Attention!</strong> L'utilisation de .innerHTML peut rendre votre code vulnérable aux attaques par
        injection de code (comme l'injection de scripts) si vous insérez du contenu non fiable. Assurez-vous de toujours
        valider ou nettoyer le contenu que vous injectez.</p>
    <p>Résultat :</p>
    <div id="monElement">
        <strong>Nouveau</strong> contenu HTML
    </div>
    <br>
    <p><code>.outerHTML</code></p>
    <ul>
        <li>Description: Cette propriété permet de récupérer ou de définir le code HTML complet de l'élément, y compris
            l'élément lui-même.</li>
    </ul>
    <p>Exemple:</p>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monElement"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Contenu<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monElement"</span>);
    element.outerHTML =
    <span class="hljs-string">'&lt;div id="monElement"&gt;&lt;strong&gt;Nouveau&lt;/strong&gt; contenu HTML&lt;/div&gt;'</span>;

    <span class="hljs-keyword">const</span> newElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monElement"</span>);
    <span class="hljs-built_in">console</span>.log(newElement.outerHTML);
    </div></code></pre>
    <p>Résultat :</p>
    <div id="monElement">
        <strong>Nouveau</strong> contenu HTML
    </div>
    <br>
    <p><strong>Créer et ajouter des éléments</strong></p>
    <p><strong>Méthodes:</strong></p>
    <ul>
        <li><code>document.createElement(tagName)</code>: crée un nouvel élément.</li>
        <li><code>.appendChild(childElement)</code>: ajoute un élément enfant à la fin.</li>
        <li><code>.insertBefore(newElement, referenceElement)</code>: insère un nouvel élément avant l'élément de
            référence.</li>
    </ul>
    <p>Exemple:</p>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monElement"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Contenu<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Ajouter un élément<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monElement"</span>);
    <span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);

    bouton.addEventListener(<span class="hljs-string">"click"</span>, () =&gt; {
    <span class="hljs-keyword">const</span> nouveauParagraphe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"p"</span>);
    nouveauParagraphe.textContent = <span class="hljs-string">"Nouveau paragraphe"</span>;
    element.appendChild(nouveauParagraphe);
    });
    </div></code></pre>
    <p>Résultat :</p>
    <div id="monElement">
        <p>Contenu</p>
        <p>Nouveau paragraphe</p>
    </div>
    <p>Manipuler le contenu du DOM est essentiel pour créer des applications web interactives. Que vous souhaitiez
        mettre à jour le texte affiché, ajouter des éléments dynamiquement ou modifier le code HTML, JavaScript offre
        les outils nécessaires pour réaliser ces tâches avec précision et efficacité.
        <br>
    </p>
    <h3 id="gestion-des-%C3%A9v%C3%A9nements">Gestion des événements</h3>
    <p>Les événements sont des actions qui se produisent dans le navigateur que JavaScript peut utiliser pour exécuter
        du code. Par exemple, lorsque l'utilisateur clique sur un bouton, un événement de clic est déclenché, et vous
        pouvez utiliser JavaScript pour gérer cet événement.</p>
    <h4 id="ajout-dun-gestionnaire-d%C3%A9v%C3%A9nements">Ajout d'un gestionnaire d'événements</h4>
    <p><strong>Méthode :</strong> <code>.addEventListener(type, listener [, options])</code></p>
    <p>Pour ajouter un gestionnaire d'événements, vous devez d'abord sélectionner l'élément sur lequel vous souhaitez
        écouter l'événement. Ensuite, vous pouvez utiliser la méthode <code>.addEventListener()</code> pour ajouter un
        gestionnaire d'événements à cet élément.</p>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Cliquez ici<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);
    bouton.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Le bouton a été cliqué."</span>);
    });
    </div></code></pre>
    <p>Résultat :</p>
    <p><button id="monBouton">Cliquez ici</button></p>
    <p>Le résultat de l'exemple ci-dessus est un bouton qui, lorsqu'il est cliqué, affiche une boîte de dialogue avec un
        message : &quot;Le bouton a été cliqué&quot;.</p>
    <p><img src="img/01.png" alt="image"></p>
    <p><strong>Note:</strong> La méthode <code>addEventListener</code> prend deux arguments : le nom de l'événement et
        la fonction de rappel (ou gestionnaire d'événements). La fonction de rappel est exécutée chaque fois que
        l'événement se produit.</p>
    <h4 id="suppression-dun-gestionnaire-d%C3%A9v%C3%A9nements">Suppression d'un gestionnaire d'événements</h4>
    <p>Pour supprimer un gestionnaire d'événements, vous pouvez utiliser la méthode
        <code>.removeEventListener(type, listener [, options])</code>.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gestionnaire</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Le bouton a été cliqué."</span>);
    }

    bouton.addEventListener(<span class="hljs-string">"click"</span>, gestionnaire);

    <span class="hljs-comment">// On supprime le gestionnaire d'événements</span>
    bouton.removeEventListener(<span class="hljs-string">"click"</span>, gestionnaire);
    </div></code></pre>
    <p>Rien ne s'affichera dans la console lorsque vous cliquez sur le bouton. Le gestionnaire d'événements a été
        supprimé.</p>
    <p><strong>Note:</strong> La méthode <code>removeEventListener</code> prend deux arguments : le nom de l'événement
        et la fonction de rappel (ou gestionnaire d'événements). La fonction de rappel est exécutée chaque fois que
        l'événement se produit.</p>
    <h4 id="propagation-d%C3%A9v%C3%A9nements">Propagation d'événements</h4>
    <p>Les événements en JavaScript se propagent en deux phases : la phase de capture et la phase de remontée
        (bubbling).</p>
    <ul>
        <li>Exemple :</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Événement sur le body!"</span>);
    });

    <span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);
    bouton.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
    alert(<span class="hljs-string">"Événement sur le bouton!"</span>);
    e.stopPropagation(); <span class="hljs-comment">// Empêche l'événement de remonter</span>
    });
    </div></code></pre>
    <ul>
        <li>
            <p>Événement sur le body!
                <img src="img/02.png" alt="image">
            </p>
        </li>
        <li>
            <p>Événement sur le bouton!
                <img src="img/03.png" alt="image">
            </p>
        </li>
    </ul>
    <p>Dans cet exemple, nous avons deux gestionnaires d'événements : un sur le body et un sur le bouton. Lorsque vous
        cliquez sur le bouton, les deux gestionnaires d'événements sont déclenchés sauf si vous utilisez
        <code>e.stopPropagation()</code>, qui empêchera la phase de remontée. C'est parce que les événements se
        propagent par défaut de l'élément le plus profond (le bouton) à l'élément le plus externe (le body).</p>
    <h4 id="objet-event">Objet Event</h4>
    <p>Lorsqu'un événement est déclenché, un objet <code>Event</code> est créé et passé à la fonction de rappel. Cet
        objet contient des informations sur l'événement, telles que l'élément sur lequel l'événement a eu lieu, le type
        d'événement, et d'autres informations spécifiques à cet événement.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);
    bouton.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
    <span class="hljs-built_in">console</span>.log(e.target); <span class="hljs-comment">// L'élément qui a déclenché l'événement. e.target est le bouton dans notre cas</span>
    });
    </div></code></pre>
    <h3 id="types-d%C3%A9v%C3%A9nements--consulter-la-liste-compl%C3%A8te-des-%C3%A9v%C3%A9nements-sur-mdn">Types
        d'événements : Consulter la liste complète des événements sur <a
            href="https://developer.mozilla.org/fr/docs/Web/Events">MDN</a></h3>
    <h4 id="%C3%A9v%C3%A9nements-de-souris">Événements de souris</h4>
    <p>Les événements de souris sont déclenchés par les actions de la souris, comme le clic, le double-clic, le survol,
        etc.
        Voyons quelques-uns des événements de souris les plus courants :</p>
    <ul>
        <li>
            <p><code>click</code> : Se produit lorsqu'un élément est cliqué.</p>
        </li>
        <li>
            <p><code>dblclick</code> : Se produit lorsqu'un élément est double-cliqué.</p>
        </li>
        <li>
            <p><code>mousedown</code> : Se produit lorsqu'un bouton de la souris est enfoncé sur un élément.</p>
        </li>
        <li>
            <p><code>mouseup</code> : Se produit lorsqu'un bouton de la souris est relâché sur un élément.</p>
        </li>
        <li>
            <p><code>mouseenter</code> : Se produit lorsqu'un curseur de souris entre dans un élément.</p>
        </li>
        <li>
            <p><code>mouseleave</code> : Se produit lorsqu'un curseur de souris quitte un élément.</p>
        </li>
        <li>
            <p><code>mousemove</code> : Se produit lorsqu'un curseur de souris se déplace sur un élément.</p>
        </li>
        <li>
            <p><code>mouseout</code> : Se produit lorsqu'un curseur de souris quitte un élément ou l'un de ses enfants.
            </p>
        </li>
        <li>
            <p><code>mouseover</code> : Se produit lorsqu'un curseur de souris entre dans un élément ou l'un de ses
                enfants.</p>
        </li>
        <li>
            <p><code>click</code> : Se produit lorsqu'un élément est cliqué.</p>
        </li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Cliquez ici<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);
    bouton.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Le bouton a été cliqué."</span>);
    });
    </div></code></pre>
    <br>
    <ul>
        <li><code>dblclick</code> : Se produit lorsqu'un élément est double-cliqué.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Cliquez ici<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);
    bouton.addEventListener(<span class="hljs-string">"dblclick"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Le bouton a été double-cliqué."</span>);
    });
    </div></code></pre>
    <p><img src="img/dbclick.png" alt="image"></p>
    <br>
    <ul>
        <li><code>mousedown</code> : Se produit lorsqu'un bouton de la souris est enfoncé sur un élément.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Cliquez ici<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);
    bouton.addEventListener(<span class="hljs-string">"mousedown"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Le bouton de la souris a été enfoncé."</span>);
    });
    </div></code></pre>
    <p><img src="img/mousedown.png" alt="image"></p>
    <br>
    <ul>
        <li><code>mouseup</code> : Se produit lorsqu'un bouton de la souris est relâché sur un élément.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Cliquez ici<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);
    bouton.addEventListener(<span class="hljs-string">"mouseup"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Le bouton de la souris a été relâché."</span>);
    });
    </div></code></pre>
    <p><img src="img/mouseup.png" alt="image"></p>
    <br>
    <ul>
        <li><code>mouseenter</code> : Se produit lorsqu'un curseur de souris entre dans un élément.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Cliquez ici<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);
    bouton.addEventListener(<span class="hljs-string">"mouseenter"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Le curseur de la souris est entré dans le bouton."</span>);
    });
    </div></code></pre>
    <p><img src="img/mouseenter.png" alt="image"></p>
    <br>
    <ul>
        <li><code>mouseleave</code> : Se produit lorsqu'un curseur de souris quitte un élément.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Cliquez ici<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monBouton"</span>);
    bouton.addEventListener(<span class="hljs-string">"mouseleave"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Le curseur de la souris a quitté le bouton."</span>);
    });
    </div></code></pre>
    <p><img src="img/mouseleave.png" alt="image"></p>
    <br>
    <ul>
        <li><code>mousemove</code> : Se produit lorsqu'un curseur de souris se déplace sur un élément.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monDiv"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monDiv"</span>);
    div.addEventListener(<span class="hljs-string">"mousemove"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Le curseur de la souris se déplace sur le div."</span>);
    });
    </div></code></pre>
    <p><img src="img/mousemove.png" alt="image"></p>
    <br>
    <ul>
        <li><code>mouseout</code> : Se produit lorsqu'un curseur de souris quitte un élément ou l'un de ses enfants.
        </li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monDiv"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Cliquez ici<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monDiv"</span>);
    div.addEventListener(<span class="hljs-string">"mouseout"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Le curseur de la souris a quitté le div."</span>);
    });
    </div></code></pre>
    <p><img src="img/mouseout.png" alt="image"></p>
    <br>
    <ul>
        <li><code>mouseover</code> : Se produit lorsqu'un curseur de souris entre dans un élément ou l'un de ses
            enfants.</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monDiv"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monBouton"</span>&gt;</span>Cliquez ici<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"monDiv"</span>);
    div.addEventListener(<span class="hljs-string">"mouseover"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">"Le curseur de la souris est entré dans le div."</span>);
    });
    </div></code></pre>
    <p><img src="img/mouseover.png" alt="image"></p>
    <br>
    <h3 id="animation-et-effets-setinterval-et-settimeout">Animation et effets: setInterval et setTimeout</h3>
    <h4 id="setinterval">setInterval</h4>
    <p>La méthode <code>setInterval()</code> permet d'exécuter une fonction à intervalles réguliers. Elle prend deux
        arguments : la fonction à exécuter et l'intervalle de temps (en millisecondes) entre chaque exécution.</p>
    <ul>
        <li>Syntaxe :</li>
    </ul>
    <pre class="hljs"><code><div>setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>, <span class="hljs-title">interval</span>, [<span class="hljs-title">arg1</span>, <span class="hljs-title">arg2</span>, ...]);
    </span></div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> compteur = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        compteur++;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Intervalle: '</span> + compteur);
        <span class="hljs-keyword">if</span> (compteur &gt;= <span class="hljs-number">5</span>) {
            clearInterval(intervalId);
        }
    }, <span class="hljs-number">1000</span>);
    </div></code></pre>
    <p>Dans cet exemple, le message &quot;Intervalle: x&quot; sera affiché chaque seconde. L'intervalle sera arrêté
        après 5 secondes grâce à la fonction clearInterval.
        Exemple d'animation</p>
    <p>Supposons que vous ayez un élément que vous souhaitez déplacer horizontalement de 10 pixels toutes les 50
        millisecondes :</p>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monDiv"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-selector-id">#monDiv</span> {
        <span class="hljs-attribute">position</span>: relative;
        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">background-color</span>: red;
    }
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'monDiv'</span>);
    <span class="hljs-keyword">let</span> position = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">const</span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        position += <span class="hljs-number">10</span>;
        element.style.left = position + <span class="hljs-string">'px'</span>;

        <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">300</span>) { <span class="hljs-comment">// Stop après avoir déplacé de 300 pixels</span>
            clearInterval(intervalId);
        }
    }, <span class="hljs-number">50</span>);
    </div></code></pre>
    <p>Dans ce code, nous utilisons la méthode <code>setInterval</code> pour déplacer l'élément de 10 pixels toutes les
        50 millisecondes. L'intervalle est arrêté lorsque l'élément a été déplacé de 300 pixels.</p>
    <p><img src="img/animation.png" alt="image"></p>
    <h4 id="settimeout">setTimeout</h4>
    <p>La méthode <code>setTimeout()</code> permet d'exécuter une fonction une seule fois après un certain délai. Elle
        prend deux arguments : la fonction à exécuter et le délai (en millisecondes) avant l'exécution.</p>
    <ul>
        <li>Syntaxe :</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> timeoutId = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>[, <span class="hljs-title">delay</span>, <span class="hljs-title">arg1</span>, <span class="hljs-title">arg2</span>, ...]);
    </span></div></code></pre>
    <ul>
        <li><code>function</code>: La fonction que vous souhaitez exécuter après le délai.</li>
        <li><code>delay</code>: Le délai en millisecondes (1000 ms = 1 s). Si ce paramètre n'est pas fourni, la valeur
            par défaut est <code>0</code>.</li>
        <li><code>arg1, arg2, ...</code>: Arguments optionnels à passer à la fonction.</li>
    </ul>
    <p>Exemple basique :</p>
    <pre class="hljs"><code><div>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        alert(<span class="hljs-string">'Affiché après 3 secondes!'</span>);
    }, <span class="hljs-number">3000</span>);
    </div></code></pre>
    <p>Dans cet exemple, une boîte d'alerte s'affiche 3 secondes après l'appel de <code>setTimeout</code>.</p>
    <p>Passer des arguments à la fonction</p>
    <pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">afficherMessage</span>(<span class="hljs-params">msg</span>) </span>{
        alert(msg);
    }

    setTimeout(afficherMessage, <span class="hljs-number">2000</span>, <span class="hljs-string">'Message après 2 secondes!'</span>);
    </div></code></pre>
    <p>Ici, nous passons un argument à la fonction afficherMessage qui sera exécutée après 2 secondes.</p>
    <p><strong>Annuler un setTimeout</strong></p>
    <p>Vous pouvez annuler un <code>setTimeout</code> à l'aide de la fonction <code>clearTimeout</code> si vous avez
        besoin d'arrêter l'exécution prévue avant qu'elle ne se produise.</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> timeoutId = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        alert(<span class="hljs-string">'Ceci ne sera pas affiché'</span>);
    }, <span class="hljs-number">5000</span>);

    <span class="hljs-comment">// Annuler le setTimeout avant qu'il ne soit exécuté</span>
    clearTimeout(timeoutId);
    </div></code></pre>
    <p>Dans cet exemple, même si nous avons défini un setTimeout, nous l'annulons immédiatement, donc la fonction ne
        sera jamais exécutée.</p>
    <p><strong>Exemple d'animation</strong></p>
    <p>Supposons que vous ayez un élément que vous souhaitez déplacer horizontalement de 10 pixels après 2 secondes :
    </p>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monDiv"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-selector-id">#monDiv</span> {
        <span class="hljs-attribute">position</span>: relative;
        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">background-color</span>: red;
    }
    </div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'monDiv'</span>);

    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        element.style.left = <span class="hljs-string">'100px'</span>;
    }, <span class="hljs-number">2000</span>);
    </div></code></pre>
    <br>
    <h3 id="manipulation-du-css">Manipulation du CSS</h3>
    <p>Avec JavaScript, vous pouvez facilement manipuler le CSS d'un élément pour changer son apparence dynamiquement.
        Voici quelques méthodes courantes pour interagir avec les styles CSS via JavaScript.</p>
    <ol>
        <li>Manipuler le style directement</li>
    </ol>
    <p>Chaque élément du DOM possède un objet style qui vous permet de lire ou de modifier ses styles en ligne.</p>
    <ul>
        <li><strong>Syntaxe :</strong></li>
    </ul>
    <pre class="hljs"><code><div>element.style.property = value;
    </div></code></pre>
    <ul>
        <li><strong>Exemple :</strong></li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'monElement'</span>);
    element.style.color = <span class="hljs-string">'blue'</span>; <span class="hljs-comment">// Change la couleur du texte</span>
    element.style.fontSize = <span class="hljs-string">'20px'</span>; <span class="hljs-comment">// Change la taille de la police</span>
    </div></code></pre>
    <ol start="2">
        <li>Ajouter ou supprimer des classes CSS</li>
    </ol>
    <p>Vous pouvez utiliser les méthodes <code>classList.add()</code>, <code>classList.remove()</code>, et
        <code>classList.toggle()</code> pour ajouter, supprimer ou basculer une classe sur un élément.</p>
    <ul>
        <li>Ajouter une classe :</li>
    </ul>
    <pre class="hljs"><code><div>element.classList.add(<span class="hljs-string">'maClasse'</span>);
    </div></code></pre>
    <ul>
        <li>Supprimer une classe :</li>
    </ul>
    <pre class="hljs"><code><div>element.classList.remove(<span class="hljs-string">'maClasse'</span>);
    </div></code></pre>
    <ul>
        <li>Basculer une classe :</li>
    </ul>
    <pre class="hljs"><code><div>element.classList.toggle(<span class="hljs-string">'maClasse'</span>);
    </div></code></pre>
    <ul>
        <li>Vérifier si un élément possède une classe :</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">if</span> (element.classList.contains(<span class="hljs-string">'maClasse'</span>)) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'L\'élément a la classe maClasse'</span>);
    }
    </div></code></pre>
    <ol start="3">
        <li>Calculer les styles appliqués</li>
    </ol>
    <p>Si vous souhaitez obtenir les styles calculés (ceux qui sont effectivement appliqués à un élément, provenant de
        feuilles de style externes, internes ou en ligne), vous pouvez utiliser <code>getComputedStyle</code>.</p>
    <ul>
        <li><strong>Syntaxe :</strong></li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">let</span> styles = <span class="hljs-built_in">window</span>.getComputedStyle(element);
    </div></code></pre>
    <ul>
        <li><strong>Exemple :</strong></li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'monElement'</span>);
    <span class="hljs-keyword">let</span> styles = <span class="hljs-built_in">window</span>.getComputedStyle(element);
    <span class="hljs-built_in">console</span>.log(styles.color); <span class="hljs-comment">// Affiche la couleur calculée de l'élément</span>
    <span class="hljs-built_in">console</span>.log(styles.fontSize); <span class="hljs-comment">// Affiche la taille de la police calculée de l'élément</span>
    </div></code></pre>
    <ol start="4">
        <li>Modifier les variables CSS (variables personnalisées)</li>
    </ol>
    <p>Les variables CSS, également appelées propriétés personnalisées, sont des entités définies par l'auteur pour
        contenir des valeurs spécifiques pour réutiliser dans tout le document. Vous pouvez les manipuler avec
        JavaScript.</p>
    <ul>
        <li><strong>Syntaxe :</strong></li>
    </ul>
    <pre class="hljs"><code><div>element.style.setProperty(<span class="hljs-string">'--maVariable'</span>, <span class="hljs-string">'maValeur'</span>);
    </div></code></pre>
    <ul>
        <li><strong>Exemple :</strong></li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.documentElement; <span class="hljs-comment">// Racine du document</span>
    element.style.setProperty(<span class="hljs-string">'--ma-couleur-principale'</span>, <span class="hljs-string">'red'</span>);
    </div></code></pre>
    <p>Ces techniques offrent une grande flexibilité pour changer l'apparence des éléments de la page Web de manière
        réactive en fonction des interactions de l'utilisateur ou d'autres événements.</p>
    <h2 id="%C3%A9v%C3%A9nements-et-gestionnaires-d%C3%A9v%C3%A9nements">Événements et gestionnaires d'événements</h2>
    <p>Lorsque vous interagissez avec une page Web, que ce soit en cliquant sur un bouton, en remplissant un formulaire
        ou même en déplaçant votre souris, des événements sont déclenchés. JavaScript vous offre la possibilité de
        &quot;écouter&quot; ces événements et d'exécuter du code en réponse à ces interactions.</p>
    <h3 id="%C3%A9couteurs-d%C3%A9v%C3%A9nements">Écouteurs d'événements</h3>
    <p>Un écouteur d'événement est une procédure dans JavaScript qui attend qu'un événement se produise, comme un clic
        sur un bouton. Une fois cet événement déclenché, l'écouteur exécute une action.</p>
    <ul>
        <li>Syntaxe pour ajouter un écouteur :</li>
    </ul>
    <pre class="hljs"><code><div>element.addEventListener(<span class="hljs-string">'typeEvenement'</span>, fonctionCallback);
    </div></code></pre>
    <ul>
        <li>Exemple :</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> bouton = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'monBouton'</span>);
    bouton.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        alert(<span class="hljs-string">'Bouton cliqué!'</span>);
    });
    </div></code></pre>
    <h3 id="%C3%A9v%C3%A9nements-de-formulaire">Événements de formulaire</h3>
    <p>Les formulaires sur les pages Web peuvent déclencher divers événements. Voici quelques-uns des plus courants :
    </p>
    <ul>
        <li>
            <p>submit : déclenché lors de la soumission d'un formulaire.</p>
        </li>
        <li>
            <p>change : déclenché lorsqu'une valeur de champ de formulaire est modifiée.</p>
        </li>
        <li>
            <p>focus : déclenché lorsqu'un élément reçoit le focus.</p>
        </li>
        <li>
            <p>blur : déclenché lorsqu'un élément perd le focus.</p>
        </li>
    </ul>
    <p>Exemple d'écouteur d'événement pour un formulaire :</p>
    <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"monFormulaire"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nom d'utilisateur"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Mot de passe"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Se connecter<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'monFormulaire'</span>);
        form.addEventListener(<span class="hljs-string">'submit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
            e.preventDefault(); <span class="hljs-comment">// Empêche le formulaire d'être soumis</span>
            alert(<span class="hljs-string">'Formulaire soumis!'</span>);
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    </div></code></pre>
    <p><img src="img/submit.png" alt="image"></p>
    <h3 id="propagation-des-%C3%A9v%C3%A9nements">Propagation des événements</h3>
    <p>Lorsqu'un événement se produit sur un élément, il ne se limite pas uniquement à cet élément. Il se propage à
        travers les éléments parent jusqu'à l'élément racine du document. Ce processus est appelé propagation
        d'événement.</p>
    <p>Il y a deux phases principales :</p>
    <ol>
        <li>
            <p>Capture (ou phase descendante) : L'événement est d'abord capturé par l'élément le plus externe et propagé
                jusqu'à l'élément sur lequel il s'est produit.</p>
        </li>
        <li>
            <p>Bubbling (ou phase ascendante) : Après avoir atteint l'élément cible, l'événement &quot;remonte&quot;
                jusqu'à l'élément le plus externe.</p>
        </li>
    </ol>
    <p>Vous pouvez utiliser la propriété <code>stopPropagation</code> pour empêcher l'événement de se propager :</p>
    <ul>
        <li>Exemple :</li>
    </ul>
    <pre class="hljs"><code><div>bouton.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        alert(<span class="hljs-string">'Bouton cliqué!'</span>);
        e.stopPropagation(); <span class="hljs-comment">// Empêche la propagation de l'événement</span>
    });
    </div></code></pre>
    <p>En comprenant comment fonctionnent les événements et leur propagation, vous pouvez écrire du code JavaScript plus
        efficace et prévisible pour gérer les interactions utilisateur.</p>
    <h2 id="traitement-asynchrone-en-javascript">Traitement asynchrone en JavaScript</h2>
    <p>Dans un environnement JavaScript, l'exécution du code se fait généralement de manière synchrone, c'est-à-dire
        ligne par ligne. Cependant, il existe de nombreuses situations où vous pourriez avoir besoin d'exécuter des
        tâches qui prennent du temps, comme des requêtes réseau, sans bloquer le reste du code. Pour gérer ces
        situations, JavaScript propose plusieurs mécanismes pour traiter le code de manière asynchrone.</p>
    <h3 id="promesses-et-asyncawait">Promesses et async/await</h3>
    <p>Les promesses sont des objets qui représentent la fin ou l'échec éventuel d'une opération asynchrone.</p>
    <p>Syntaxe d'une promesse :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> maPromesse = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// Opération asynchrone</span>
    <span class="hljs-keyword">if</span> (maCondition) {
        resolve(<span class="hljs-string">'Résultat réussi'</span>);
    } <span class="hljs-keyword">else</span> {
        reject(<span class="hljs-string">'Erreur survenue'</span>);
    }
    });
    </div></code></pre>
    <ul>
        <li>Utilisation de la promesse :</li>
    </ul>
    <pre class="hljs"><code><div>maPromesse.then(<span class="hljs-function"><span class="hljs-params">resultat</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(resultat);
    }).catch(<span class="hljs-function"><span class="hljs-params">erreur</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.error(erreur);
    });
    </div></code></pre>
    <p><code>async/await</code> est une manière plus élégante de travailler avec des promesses :</p>
    <ul>
        <li>Syntaxe async/await :</li>
    </ul>
    <pre class="hljs"><code><div><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fonctionAsynchrone</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> resultat = <span class="hljs-keyword">await</span> maPromesse;
        <span class="hljs-built_in">console</span>.log(resultat);
    } <span class="hljs-keyword">catch</span> (erreur) {
        <span class="hljs-built_in">console</span>.error(erreur);
    }
    }
    </div></code></pre>
    <h3 id="ajax-et-fetch-api">AJAX et Fetch API</h3>
    <p>AJAX (Asynchronous JavaScript And XML) est une technique qui permet d'envoyer et de recevoir des données d'un
        serveur sans avoir à recharger la page.</p>
    <p>La Fetch API est l'outil moderne pour effectuer des requêtes AJAX :</p>
    <p>Exemple d'utilisation de Fetch :</p>
    <pre class="hljs"><code><div>fetch(<span class="hljs-string">'https://api.exemple.com/donnees'</span>)
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
    .then(<span class="hljs-function"><span class="hljs-params">donnees</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(donnees);
    })
    .catch(<span class="hljs-function"><span class="hljs-params">erreur</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Erreur :'</span>, erreur);
    });
    </div></code></pre>
    <h3 id="websockets-et-communication-en-temps-r%C3%A9el">WebSockets et communication en temps réel</h3>
    <p>Les WebSockets fournissent un canal de communication bidirectionnel entre le client et le serveur. C'est idéal
        pour les applications qui nécessitent des mises à jour en temps réel, comme les chats ou les jeux.</p>
    <p>Exemple de création d'un WebSocket :</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">'ws://monserveur.com'</span>);

    socket.onopen = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        socket.send(<span class="hljs-string">'Salut Serveur!'</span>);
    };

    socket.onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Message reçu:'</span>, event.data);
    };
    </div></code></pre>
    <p>Avec ces outils et techniques, JavaScript est bien équipé pour gérer toutes sortes d'opérations asynchrones, que
        ce soit des requêtes de données, des retards programmés ou des communications en temps réel.</p>
    <h2 id="frameworks-et-biblioth%C3%A8ques-populaires">Frameworks et bibliothèques populaires</h2>
    <p>La richesse de l'écosystème JavaScript s'illustre par l'abondance de ses frameworks et bibliothèques, qui
        facilitent et accélèrent le développement d'applications. Ces outils sont conçus pour répondre à divers besoins,
        de la construction d'interfaces utilisateur réactives à la création d'API robustes côté serveur.</p>
    <h3 id="vuejs">Vue.js</h3>
    <p>Vue.js est un framework progressif pour construire des interfaces utilisateur. Conçu pour être adopté de manière
        incrémentielle, Vue est parfaitement capable de propulser des applications monopages complexes en se combinant
        avec des outils modernes et des bibliothèques complémentaires.</p>
    <p><strong>Caractéristiques principales :</strong></p>
    <ul>
        <li>Réactif : Facilite la création d'interfaces riches et interactives.</li>
        <li>Composable : Vous pouvez utiliser autant ou aussi peu de Vue que vous le souhaitez.</li>
    </ul>
    <h3 id="react">React</h3>
    <p>Développé et soutenu par Facebook, React est une bibliothèque pour construire des interfaces utilisateur. Il vous
        permet de créer des vues complexes à partir de petits composants réutilisables.</p>
    <p><strong>Caractéristiques principales :</strong></p>
    <ul>
        <li>Composant : Tout est un composant dans React, facilitant la réutilisation de code.</li>
        <li>Unidirectionnel : Le flux de données unidirectionnel rend le débogage plus facile.</li>
    </ul>
    <h3 id="angular">Angular</h3>
    <p>Angular est un framework plateforme pour construire des applications web avec HTML, CSS et JavaScript/TypeScript.
        Il est complet et fournit de nombreux outils hors de la boîte pour le développement d'applications complexes.
    </p>
    <p><strong>Caractéristiques principales :</strong></p>
    <ul>
        <li>Batteries incluses : Inclut tout, de la gestion de l'état à la mise en réseau HTTP.</li>
        <li>TypeScript : Angular est écrit en TypeScript, apportant de la puissance à la POO et à la vérification de
            types.</li>
    </ul>
    <h3 id="backend-frameworks-ex-nestjs-meteor">Backend frameworks (ex: Nest.js, Meteor)</h3>
    <p><strong>Nest.js :</strong> Un framework pour construire des applications server-side efficaces et évolutives avec
        JavaScript. Il utilise TypeScript et est fortement inspiré par Angular.</p>
    <ul>
        <li>Modulaire : Structurez votre application avec différents modules pour une meilleure organisation.</li>
        <li>Décorateurs : Utilisez des décorateurs pour une syntaxe plus concise et expressive.</li>
    </ul>
    <p><strong>Meteor :</strong> Une plateforme complète pour construire des applications web et mobiles en JavaScript
        pur.</p>
    <ul>
        <li>Temps réel par défaut : Toutes les couches, de la base de données à votre template, sont mises à jour
            automatiquement.</li>
        <li>Full-stack : Meteor vous donne tout ce dont vous avez besoin, de la base de données à la mise en réseau
            HTTP.</li>
    </ul>
    <p>Ces outils, parmi d'autres, rendent le développement en JavaScript plus efficace et agréable, permettant aux
        développeurs de se concentrer sur la création d'applications impressionnantes plutôt que sur les détails de mise
        en œuvre.</p>
    <h2 id="bonnes-pratiques-et-s%C3%A9curit%C3%A9">Bonnes pratiques et sécurité</h2>
    <p>Lorsque vous développez en JavaScript, il est crucial de suivre les meilleures pratiques pour garantir que votre
        code soit propre, maintenable et, surtout, sécurisé. Comme tout langage de programmation puissant, JavaScript
        peut être utilisé de manière incorrecte, ce qui peut entraîner des bogues, des problèmes de performances ou des
        vulnérabilités de sécurité.</p>
    <h3 id="%C3%A9criture-de-code-maintenable">Écriture de code maintenable</h3>
    <p><strong>L'écriture de code maintenable</strong> est au cœur d'un développement sain. Cela garantit que votre code
        peut être facilement compris, modifié et étendu par d'autres développeurs, ou par vous-même à l'avenir.</p>
    <ul>
        <li><strong>Commentaires</strong> : Documentez votre code pour expliquer pourquoi certaines décisions ont été
            prises.</li>
        <li><strong>Nommage</strong> : Utilisez des noms de variables et de fonctions descriptifs.</li>
        <li><strong>DRY (Don't Repeat Yourself)</strong> : Réutilisez le code autant que possible pour réduire les
            répétitions.</li>
    </ul>
    <h3 id="outils-de-d%C3%A9bogage">Outils de débogage</h3>
    <ul>
        <li><strong>Console :</strong> Utilisez console.log(), console.debug() et autres méthodes pour inspecter les
            valeurs pendant l'exécution.</li>
        <li><strong>Navigateur :</strong> Les navigateurs modernes offrent des outils de développement intégrés pour
            déboguer le code, inspecter le DOM et surveiller les requêtes réseau.</li>
    </ul>
    <h3 id="pr%C3%A9vention-des-vuln%C3%A9rabilit%C3%A9s-courantes">Prévention des vulnérabilités courantes</h3>
    <p>La sécurité doit toujours être une priorité. Connaître les vulnérabilités courantes peut vous aider à écrire un
        code plus sécurisé.</p>
    <ul>
        <li><strong>Cross-Site Scripting (XSS) :</strong> Évitez d'insérer du contenu non filtré dans le DOM.</li>
        <li><strong>Cross-Site Request Forgery (CSRF) :</strong> Utilisez des tokens anti-CSRF dans vos formulaires.
        </li>
        <li><strong>Injections :</strong> Assurez-vous de filtrer et de désinfecter les entrées utilisateur avant de les
            traiter.</li>
    </ul>
    <h2 id="annexes">Annexes</h2>
    <p>Il est toujours utile d'avoir une section d'annexes dans votre documentation ou votre livre. Cela peut fournir
        des informations supplémentaires, des éclaircissements ou des détails sur les sujets abordés.</p>
    <h3 id="ressources-suppl%C3%A9mentaires">Ressources supplémentaires</h3>
    <ul>
        <li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript">MDN Web Docs</a></li>
        <li><a href="https://javascript.info/">JavaScript.info</a></li>
        <li><a href="https://www.w3schools.com/js/default.asp">W3Schools</a></li>
    </ul>
    <h3 id="glossaire">Glossaire</h3>
    <ul>
        <li><strong>DOM</strong> : Document Object Model (Modèle d'Objet de Document) est une interface de programmation
            pour les documents HTML et XML.</li>
        <li><strong>API</strong> : Application Programming Interface (Interface de Programmation d'Application) est un
            ensemble de définitions et de protocoles qui facilite la création et l'intégration de logiciels
            d'applications.</li>
        <li><strong>AJAX</strong> : Asynchronous JavaScript And XML (JavaScript et XML Asynchrones) est une technique
            qui permet d'envoyer et de recevoir des données d'un serveur sans avoir à recharger la page.</li>
        <li><strong>XSS</strong> : Cross-Site Scripting (Script intersite) est une vulnérabilité qui permet à un
            attaquant d'injecter du code malveillant dans une application web.</li>
        <li><strong>CSRF</strong> : Cross-Site Request Forgery (Falsification de requête intersite) est une attaque qui
            force un utilisateur à exécuter des actions non voulues sur un site web auquel il est authentifié.</li>
        <li><strong>DRY</strong> : Don't Repeat Yourself (Ne vous répétez pas) est un principe de programmation qui
            consiste à éviter la répétition de code.</li>
        <li><strong>POO</strong> : Programmation Orientée Objet est un paradigme de programmation basé sur le concept
            d'objets.</li>
        <li><strong>TypeScript</strong> : TypeScript est un langage de programmation open-source développé par Microsoft
            qui ajoute des types à JavaScript.</li>
        <li><strong>WebSocket</strong> : WebSocket est une technologie qui fournit un canal de communication
            bidirectionnel entre le client et le serveur.</li>
        <li><strong>Framework</strong> : Un framework est un ensemble d'outils et de composants logiciels qui facilitent
            le développement d'applications.</li>
        <li><strong>Bibliothèque</strong> : Une bibliothèque est un ensemble de fonctions réutilisables qui peuvent être
            utilisées pour le développement de logiciels.</li>
        <li><strong>Promesse</strong> : Une promesse est un objet qui représente la fin ou l'échec éventuel d'une
            opération asynchrone.</li>
        <li><strong>Async/await</strong> : Async/await est une manière plus élégante de travailler avec des promesses.
        </li>
    </ul>
    <h3 id="r%C3%A9f%C3%A9rences">Références</h3>
    <ul>
        <li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript">MDN Web Docs</a></li>
        <li><a href="https://javascript.info/">JavaScript.info</a></li>
        <li><a href="https://www.w3schools.com/js/default.asp">W3Schools</a></li>
    </ul>

</body>

</html>